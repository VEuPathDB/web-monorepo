#!/usr/bin/perl

use strict;

#!/usr/bin/perl -w

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Data::Dumper;
use XML::Simple;
use Time::HiRes qw(gettimeofday);

use DBI;
use List::Util qw(min max);
use Getopt::Long qw(GetOptions);
use GUS::Supported::GusConfig;
use GUS::ObjRelP::DbiDatabase;

my ($sanityFile, $gbrowseFile, $indexOnly, $failuresOnly, $suggestOnly, $skipTo, $stopAfter, $showParseG, $showParseS);
my $gusConfigFile = "$ENV{GUS_HOME}/config/gus.config";

$stopAfter = 1000;
GetOptions("sanityFile=s" => \$sanityFile,
	   "gbrowseFile=s" => \$gbrowseFile,
           "indexOnly!" => \$indexOnly,
           "failuresOnly!" => \$failuresOnly,
           "suggestOnly!" => \$suggestOnly,
           "skipTo=i" => \$skipTo,
           "stopAfter=i" => \$stopAfter,
           "showParseG!" => \$showParseG,
           "showParseS!" => \$showParseS,
	  );

&usage unless ($sanityFile && $gbrowseFile);

&usage if ($indexOnly && $suggestOnly);

my ($sanityConfig, $defaultParams, $sqlValues) =
  &parseSanityFile($sanityFile, $showParseS);

my $gbrowseConfig = &parseGbrowseFile($gbrowseFile, $showParseG);

if ($indexOnly) {
  &showIndex($sanityConfig);
  exit(0);
}

my ($queryNameHash, $queryNameArray) = &getQueryNameHash($gbrowseConfig);

my $parentFeatureTests = {};   # tests that subfeature queries refer to

&validateTests($queryNameHash, $queryNameArray, $sanityConfig, $suggestOnly, $defaultParams, $parentFeatureTests);

exit(0) if ($suggestOnly);

my $dbh = getDbHandle();

&runTests($dbh, $queryNameHash, $sanityConfig, $failuresOnly, $skipTo,
	  $stopAfter, $defaultParams, $parentFeatureTests);

###################################################################

sub usage {
  die
q{
Test all sql in a gbrowse XML file

Usage: gbrowseSanityTest --sanityFile sanityTestConfigFile --gbrowseFile gbrowseXmlFile [--indexOnly | --suggestOnly | --failuresOnly] [--skipTo testnum] [--stopAfter testnum] [--showParseG] [--showParseS]

Where:
  sanityFile     an xml file containing the configuration for the test
  gbrowseFile    the xml file that contains the queries used by gbrowse
  indexOnly      don't run the test. only print tests and their test number
  suggestOnly    don't run test. only print templates for missing tests
  failuresOnly   run the test but only report the failures
  skipTo         the index of the first test to run
  stopAfter      the index of the last test to run
  showParseG     show the data structure resulting from the parse of gbrowseFile
  showParseS     show the data structure resulting from the parse of sanityFile



Sample sanity file XML:
<gbrowseSanity>
    <defaultParamValue name="rend" value="500000"/>
    <defaultParamValue name="base_start" value="1000"/>
    <defaultParamValue name="dlm" value=","/>
    <defaultParamValue name="srcfeature_id" value="$$na_seq_id_MAL3$$"/>

    <sqlValue name="na_seq_id_MAL3">
      <sql>
      select na_sequence_id from dots.externalnasequence where source_id = 'MAL3'
      </sql>
    </sqlValue>

    <sqlValue name="na_feat_id_PF11_0344">
      <sql>
      select na_feature_id from dots.genefeature where source_id = 'PF11_0344'
      </sql>
    </sqlValue>

    <test name="get_feature_by_name" min="1" max="2000">
      <param name="name" value="MAL1"/>
    </test>

    <test name="get_sequence" min="1" max="2000">
    </test>

    <test name="annotation:density:subfeatures" min="1" max="2000">
      <param name="parent_id" value="$$na_feat_id_PF11_0344$$"/>
    </test>

    <test name="match:TGI" min="1" max="2000">
    </test>

    <test name="match:TGI:subfeatures" min="1" max="20">
      <param name="parent_id" parentFeatureTest="match:TGI"/>
    </test>

</gbrowseSanity>
};
}

sub parseSanityFile {
  my($sanityFile, $showParse) = @_;

  open(FILE, $sanityFile) || die "can't open sanity file '$sanityFile' for reading\n";
  my $simple = XML::Simple->new();

  # use forcearray so elements with one child are still arrays
  # and, use keyattr so that handlers are given as an ordered list
  # rather than a hash with name as key.  the ordering is needed
  # so that undo operations are ordered.  also, the qualifiers retain
  # the ordering found in the xml file.
  my $data = $simple->XMLin($sanityFile,
			    forcearray => 1,
			    KeyAttr => {});
  if ($showParse) {
    print Dumper($data);
    print "\n\n\n";
  }
  my $defaultParams = {};
  foreach my $defaultParamValue (@{$data->{defaultParamValue}}) {
    $defaultParams->{$defaultParamValue->{name}} =
      {value=> $defaultParamValue->{value}, sql => $defaultParamValue->{value}};
  }

  return ($data, $defaultParams);
}

sub showIndex {
  my ($sanityConfig) = @_;

  my $count = 0;
  foreach my $test (@{$sanityConfig->{test}}) {
    $count++;
    my $testString = &test2string($test);
    print "$testString [test: $count]\n\n";
  }
}

sub test2string {
  my ($test) = @_;


  my @paramStrings;
  foreach my $param (@{$test->{param}}) {
    my $paramString = "-$param->{name} '";
    $paramString .= $param->{parentFeatureTest}?
      $param->{parentFeatureTest} : $param->{value};
    $paramString .= "'";
    push(@paramStrings, $paramString);
  }
  my $paramsString = join(" ", @paramStrings);
  return "$test->{name} $paramsString";
}

sub parseGbrowseFile {
  my($gbrowseFile, $showParse) = @_;

  open(FILE, $gbrowseFile) || die "can't open gbrowse file '$gbrowseFile' for reading\n";
  my $simple = XML::Simple->new();

  # use forcearray so elements with one child are still arrays
  # and, use keyattr so that handlers are given as an ordered list
  # rather than a hash with name as key.  the ordering is needed
  # so that undo operations are ordered.  also, the qualifiers retain
  # the ordering found in the xml file.
  my $data = $simple->XMLin($gbrowseFile,
			    forcearray => 1,
	      	    KeyAttr => {});
  if ($showParse) {
    print Dumper($data);
    print  "\n\n\n";
  }
  return $data;
}

sub validateTests {
  my ($queryNameHash, $queryNameArray, $sanityConfig, $suggestOnly, $defaultParams, $parentFeatureTests) = @_;

  my %testedQueryNames =
    &getTestedQueryNames($sanityConfig, $parentFeatureTests);

  foreach my $queryName (@$queryNameArray) {
    my $query = $queryNameHash->{$queryName};
    if (!$testedQueryNames{$queryName}) {
      if ($suggestOnly) {
	my @paramNames = &getQueryParamNames($query->{sql}->[0]);
	print qq{    <test name="$query->{name}->[0]" min="FIX_default_min" max="FIX_default_max">\n};
	foreach my $paramName (@paramNames) {
	  next if ($defaultParams->{$paramName});
	  print qq{      <param name="$paramName" value=""/>\n};
	}
	print "    </test>\n\n";
      } else {
	print "NO TEST FOR: $queryName\n\n";
      }
    }
  }

  foreach my $testedQueryName (keys %testedQueryNames) {
    print "TEST OF NON-EXISTENT QUERY: '$testedQueryName'\n\n"
      unless $queryNameHash->{$testedQueryName};
    ## make sure we have a name and value for the param
  }
}

sub getQueryNameHash {
  my ($gbrowseConfig) = @_;

  my $qnh = {};
  my @qna;
  foreach my $module (@{$gbrowseConfig->{module}}) {
    foreach my $sqlQuery (@{$module->{sqlQuery}}) {
      push(@qna, $sqlQuery->{name}->[0]);
      $qnh->{$sqlQuery->{name}->[0]} = $sqlQuery;
    }
  }
  return ($qnh,\@qna);
}

sub getTestedQueryNames {
  my ($sanityConfig, $parentFeatureTests) = @_;

  my %testedNames;
  my $count=0;
  foreach my $test (@{$sanityConfig->{test}}) {
    $count++;
    $test->{min} && $test->{max} || die "test $count ($test->{name}) missing either min or max\n";
    $testedNames{$test->{name}} = 1;
    foreach my $param (@{$test->{param}}) {
      if ($param->{parentFeatureTest}) {
	$parentFeatureTests->{$param->{parentFeatureTest}} = 1;
      }
    }
  }
  foreach my $test (@{$sanityConfig->{test}}) {
    if ($parentFeatureTests->{$test->{name}}) {
      $parentFeatureTests->{$test->{name}} = {test => $test};
    }
  }
  return %testedNames;
}

sub getQueryParamNames {
  my ($sqlString) = @_;

  my %paramNames;
  while ($sqlString =~ /\$(\w+)/g){
    $paramNames{$1} = 1;
  }
  return keys %paramNames;
}

sub getDbHandle {
  my $gusconfig = GUS::Supported::GusConfig->new();

  my $db = GUS::ObjRelP::DbiDatabase->new($gusconfig->getDbiDsn(),
					  $gusconfig->getDatabaseLogin(),
					  $gusconfig->getDatabasePassword(),
					  0,0,1,
					  $gusconfig->getCoreSchemaName()
					 );
  my $dbh = $db->getQueryHandle();
  return $dbh;
}



sub runTests {
  my ($dbh, $queryNameHash, $sanityConfig, $failuresOnly, $skipTo, $stopAfter, $defaultParams, $parentFeatureTests) = @_;

  my $sqlValues = &getSqlValues($dbh, $sanityConfig->{sqlValue});

  my $count = 0;
  my $passed = 0;
  my $failed = 0;
  my $runCount = 0;

  foreach my $test (@{$sanityConfig->{test}}) {
    $count++;
    next if ($count < $skipTo);
    last if ($count > $stopAfter);
    $runCount++;
    my $testString = &test2string($test);

    my ($parentFeatureId, $parentFeatureRowCount) =
      &findParentFeatureId($dbh, $test->{param}, $defaultParams, $sqlValues,
			   $parentFeatureTests);

    my $time = gettimeofday();
    my ($rowCount, $sqlString) = 
      &runSingleTest($dbh, $test, $defaultParams,
		     $sqlValues, $parentFeatureTests, $parentFeatureId);
    my $totTime = gettimeofday() - $time;
    $totTime = int($totTime * 10000)/10000;
    my $multiplier = "";
    if ($parentFeatureId) {
      $multiplier = " ($totTime multiplied by $parentFeatureRowCount parent feature rows)";
      $totTime *= $parentFeatureRowCount;
    }
    if ($rowCount >= $test->{min} && $rowCount <= $test->{max}) {
      print "$totTime$multiplier PASSED $testString (returned $rowCount) [test: $count]\n\n"
	unless $failuresOnly;
      $passed++;
    } else {
      $failed++;
      print "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n";
      print "$totTime FAILED $testString [test: $count] expected $test->{min} to $test->{max}.  got: $rowCount

sql:
$sqlString
";
      print "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n";
    }

  }
  print "
Ran $runCount tests
  $passed passed
  $failed failed
";
}
sub runSingleTest {
  my ($dbh, $test, $defaultParams, $sqlValues, $parentFeatureTests, $parentFeatureId) = @_;
  my $rawSqlString = $queryNameHash->{$test->{name}}->{sql}->[0];

  my $sqlString = &interpolateParams($rawSqlString, $defaultParams,
				     $test->{name},
				     $test->{param}, $sqlValues,
				     $parentFeatureId);
  my $stmt = $dbh->prepare($sqlString);
  $stmt->execute();
  my $rowCount = 0;
  my $parentFeatureTest = $parentFeatureTests->{$test->{name}};
  my $parentFeatureId;

  while (my $row = $stmt->fetchrow_hashref()) {
    $rowCount++;
    # if we have a feature_id, remember it in case there is a subfeature query
    # that might need it.
    $parentFeatureId = $row->{FEATURE_ID} if $rowCount == 1;
  }
  if ($parentFeatureTest) {
    $parentFeatureTest->{featureId} = $parentFeatureId;
    $parentFeatureTest->{rowCount} = $rowCount;
  }

  return ($rowCount, $sqlString);
}

sub findParentFeatureId {
  my ($dbh, $params, $defaultParams, $sqlValues, $parentFeatureTests) = @_;
  my $parentFeatureId;
  my $parentFeatureRowCount;

  foreach my $param (@$params) {
    next unless $param->{parentFeatureTest};
    my $parentTestStuff = $parentFeatureTests->{$param->{parentFeatureTest}};
    if (!$parentTestStuff->{featureId}) {
      print STDERR "(running test '$parentTestStuff->{test}->{name}' to get parent feature id)\n";
      &runSingleTest($dbh, $parentTestStuff->{test}, $defaultParams,
		     $sqlValues, $parentFeatureTests);
    }
    $parentFeatureId = $parentTestStuff->{featureId};
    $parentFeatureRowCount = $parentTestStuff->{rowCount};
  }
  return ($parentFeatureId, $parentFeatureRowCount);
}

sub getSqlValues {
  my ($dbh, $sqlValueElements) = @_;

  my $answer = {};
  foreach my $sqlValue (@$sqlValueElements) {
    my $sql = $sqlValue->{sql}->[0];
    my $stmt = $dbh->prepare($sql);
    $stmt->execute();
    my $rowCount;
    while (my @result = $stmt->fetchrow_array()) {
      $rowCount++;
      die ("sqlValue $sqlValue->{name} does not return 1 row ($rowCount)") unless $rowCount == 1;
      my $columnCount = scalar(@result);
      die ("sqlValue $sqlValue->{name} does not return 1 column ($columnCount)")
	unless $columnCount == 1;
      $answer->{$sqlValue->{name}} = $result[0];
    }
  }
  return $answer;
}

sub interpolateParams {
  my ($rawSqlString, $defaultParams, $testName, $params, $sqlValues,$parentFeatureId) = @_;

  my $sqlString = $rawSqlString;

  # first do explicit values
  foreach my $param (@$params) {
    my $macro = '\$' . $param->{name};
    my $val = $param->{value};
    if ($param->{parentFeatureTest}) {
      $val = $parentFeatureId;
      die("Can't find feature_id from parent test '$param->{parentFeatureTest}'") unless $val;
   }
    $val = &substituteSqlValue($val, $sqlValues);
    $sqlString =~ s/$macro/$val/g if $val;
  }

  # then defaults
  foreach my $paramName (keys %$defaultParams) {
    my $macro = '\$' . $paramName;
    my $val = $defaultParams->{$paramName}->{value};
    $val = &substituteSqlValue($val, $sqlValues);
    $sqlString =~ s/$macro/$val/g;
  }

  foreach my $param (@$params) {
    my $macro = '\$' . $param->{name};
    die("Can't find value for param '$param->{name}' of test '$testName'") 
       if $sqlString =~ /$macro/;
  }

  return $sqlString;
}

sub substituteSqlValue {
  my ($macroMaybe, $sqlValues) = @_;

  my $val = $macroMaybe;

  if ($macroMaybe =~ /\$\$(\S+)\$\$/) {
    $val = $sqlValues->{$1};
    die ("couldn't find sqlValue for macro '$macroMaybe'") unless $val;
  }

  return $val;
}


