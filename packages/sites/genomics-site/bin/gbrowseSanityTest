#!/usr/bin/perl

use strict;

#!/usr/bin/perl -w

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Data::Dumper;
use XML::Simple;
use Time::HiRes qw(gettimeofday);

use DBI;
use List::Util qw(min max);
use Getopt::Long qw(GetOptions);
use ApiCommonWebsite::Model::ModelConfig;

my ($sanityFile, $model, $gbrowseFile, $indexOnly, $failuresOnly, $suggestOnly, $skipTo, $stopAfter, $showParseG, $showParseS, $showSql, $showCommentedSql, $sqlMode, $showDbInfo);

$stopAfter = 1000;
GetOptions("sanityFile=s" => \$sanityFile,
           "model=s" => \$model,
           "gbrowseFile=s" => \$gbrowseFile,
           "indexOnly!" => \$indexOnly,
           "failuresOnly!" => \$failuresOnly,
           "suggestOnly!" => \$suggestOnly,
           "skipTo=i" => \$skipTo,
           "stopAfter=i" => \$stopAfter,
           "showParseG!" => \$showParseG,
           "showParseS!" => \$showParseS,
           "showSql!" => \$showSql,
           "showCommentedSql!" => \$showCommentedSql,
           "showDbInfo!" => \$showDbInfo,
	  );

&usage unless ($sanityFile && $gbrowseFile && $model);

&usage if ($indexOnly && $suggestOnly);

$sqlMode = $showSql;
$sqlMode = 'commented' if $showCommentedSql;

my ($sanityConfig, $defaultParams, $sqlValues) =
  &parseSanityFile($sanityFile, $showParseS);

my $gbrowseConfig = &parseGbrowseFile($gbrowseFile, $showParseG);

if ($indexOnly) {
  &showIndex($sanityConfig);
  exit(0);
}

my ($queryNameHash, $queryNameArray) = &getQueryNameHash($gbrowseConfig);

my $parentFeatureTests = {};   # tests that subfeature queries refer to

&validateTests($queryNameHash, $queryNameArray, $sanityConfig, $suggestOnly, $defaultParams, $parentFeatureTests);

exit(0) if ($suggestOnly);

my $dbh = getDbHandle($showDbInfo);

&runTests($dbh, $queryNameHash, $sanityConfig, $failuresOnly, $skipTo,
	  $stopAfter, $defaultParams, $parentFeatureTests, $sqlMode);

###################################################################

sub usage {
  die
q{
Test all sql in a gbrowse XML file

Usage: gbrowseSanityTest --sanityFile sanityTestConfigFile --model PlasmoDB --gbrowseFile gbrowseXmlFile [--indexOnly | --suggestOnly | --failuresOnly] [--skipTo testnum] [--stopAfter testnum] [--showParseG] [--showParseS] [--showSql] [--showCommentedSql] [--showDbInfo]

Where:
  sanityFile       an xml file containing the configuration for the test
  model            the name of the model in WDK parlance
  gbrowseFile      the xml file that contains the queries used by gbrowse
  indexOnly        don't run the test. only print tests and their test number
  suggestOnly      don't run test. only print templates for missing tests
  failuresOnly     run the test but only report the failures
  skipTo           the index of the first test to run
  stopAfter        the index of the last test to run
  showParseG       show the data structure resulting from the parse of gbrowseFile
  showParseS       show the data structure resulting from the parse of sanityFile
  showSql          show the SQL even if the test passes
  showCommentedSql like --showSql, but with macro names labelled in SQL comments
                    (note that this can cause errors for macros inside quotes)
  showDbInfo       show the database connection info (dsn and login)


Sample sanity file XML:
<gbrowseSanity>
    <defaultParamValue name="rend" value="500000"/>
    <defaultParamValue name="base_start" value="1000"/>
    <defaultParamValue name="dlm" value=","/>
    <defaultParamValue name="srcfeature_id" value="$$na_seq_id_MAL3$$"/>

    <sqlValue name="na_seq_id_MAL3">
      <sql>
      select na_sequence_id from dots.externalnasequence where source_id = 'MAL3'
      </sql>
    </sqlValue>

    <sqlValue name="na_feat_id_PF11_0344">
      <sql>
      select na_feature_id from dots.genefeature where source_id = 'PF11_0344'
      </sql>
    </sqlValue>

    <test name="get_feature_by_name" min="1" max="2000">
      <param name="name" value="MAL1"/>
    </test>

    <test name="get_sequence" min="1" max="2000">
    </test>

    <test name="annotation:density:subfeatures" min="1" max="2000">
      <param name="parent_id" value="$$na_feat_id_PF11_0344$$"/>
    </test>

    <test name="match:TGI" min="1" max="2000">
    </test>

    <test name="match:TGI:subfeatures" min="1" max="20">
      <param name="parent_id" parentFeatureTest="match:TGI"/>
    </test>

</gbrowseSanity>


Strategy for Making a Sanity Test File

Step 1: create an "empty" sanity test file with only the <gbrowseSanity> and
        <defaultParamValue> tags filled in. The more <defaultParamValue> tags
        you include, the easier it will be in following steps.

Step 2: run the test in --suggestOnly mode (and write the output to a temp file).
        The file will contain templates for suggested tests to include in your
        sanity test file.  Notice that tests do not include template <param> tags
        if you have supplied a default for that type of param.

Step 3: paste the suggested tests into your empty sanity test file.  Now it isn't
        "empty" any more.

Step 4: create <sqlValue> tags.  Use one of these when there is a <param> or 
        <defaultParamValue> that expects an internal ID (eg, an na_sequence_id)
        as a value.  Because your sanity test file will go into SVN, you do not
        want to pollute it with hard-coded internal IDs.  Instead, use an
        <sqlValue> tag to write sql that will produce an internal ID from a 
        stable ID.  Give the <sqlValue> a unique name.  You can now refer to it
        in any <param> or <defaultParamValue> by using the $$ macro syntax (see
        the sample sanity file above).

Step 5: for any <param> that still has a missing value, provide that value in
        the <param> tag.

Step 6: some subfeature queries are parameterized by a $parent_id which is
        the ID of the parent feature. In those <param> tags, use the 
        parentFeatureTest attribute to point to a parent test that can provide
        the value for $parent_id.  (See the match:TGI example in the sample
        sanity file above)

Step 7: now you can run the test


};
}

sub parseSanityFile {
  my($sanityFile, $showParse) = @_;

  open(FILE, $sanityFile) || die "can't open sanity file '$sanityFile' for reading\n";
  my $simple = XML::Simple->new();

  # use forcearray so elements with one child are still arrays
  # and, use keyattr so that handlers are given as an ordered list
  # rather than a hash with name as key.  the ordering is needed
  # so that undo operations are ordered.  also, the qualifiers retain
  # the ordering found in the xml file.
  my $data = $simple->XMLin($sanityFile,
			    forcearray => 1,
			    KeyAttr => {});
  if ($showParse) {
    print Dumper($data);
    print "\n\n\n";
  }
  my $defaultParams = {};
  foreach my $defaultParamValue (@{$data->{defaultParamValue}}) {
    $defaultParams->{$defaultParamValue->{name}} =
      {value=> $defaultParamValue->{value}, sql => $defaultParamValue->{value}};
  }

  return ($data, $defaultParams);
}

sub showIndex {
  my ($sanityConfig) = @_;

  my $count = 0;
  foreach my $test (@{$sanityConfig->{test}}) {
    $count++;
    my $testString = &test2string($test);
    print "$testString [test: $count]\n\n";
  }
}

sub test2string {
  my ($test) = @_;


  my @paramStrings;
  foreach my $param (@{$test->{param}}) {
    my $paramString = "-$param->{name} '";
    $paramString .= $param->{parentFeatureTest}?
      $param->{parentFeatureTest} : $param->{value};
    $paramString .= "'";
    push(@paramStrings, $paramString);
  }
  my $paramsString = join(" ", @paramStrings);
  return "$test->{name} $paramsString";
}

sub parseGbrowseFile {
  my($gbrowseFile, $showParse) = @_;

  open(FILE, $gbrowseFile) || die "can't open gbrowse file '$gbrowseFile' for reading\n";
  my $simple = XML::Simple->new();

  # use forcearray so elements with one child are still arrays
  # and, use keyattr so that handlers are given as an ordered list
  # rather than a hash with name as key.  the ordering is needed
  # so that undo operations are ordered.  also, the qualifiers retain
  # the ordering found in the xml file.
  my $data = $simple->XMLin($gbrowseFile,
			    forcearray => 1,
	      	    KeyAttr => {});
  if ($showParse) {
    print Dumper($data);
    print  "\n\n\n";
  }
  return $data;
}

sub validateTests {
  my ($queryNameHash, $queryNameArray, $sanityConfig, $suggestOnly, $defaultParams, $parentFeatureTests) = @_;

  my %testedQueryNames =
    &getTestedQueryNames($sanityConfig, $parentFeatureTests);

  foreach my $queryName (@$queryNameArray) {
    my $query = $queryNameHash->{$queryName};
    if (!$testedQueryNames{$queryName}) {
      if ($suggestOnly) {
	my @paramNames = &getQueryParamNames($query->{sql}->[0]);
	print qq{    <test name="$query->{name}->[0]" min="FIX_default_min" max="FIX_default_max">\n};
	foreach my $paramName (@paramNames) {
	  next if ($defaultParams->{$paramName});
	  print qq{      <param name="$paramName" value=""/>\n};
	}
	print "    </test>\n\n";
      } else {
	print "NO TEST FOR: $queryName\n\n";
      }
    }
  }

  foreach my $testedQueryName (keys %testedQueryNames) {
    print "TEST OF NON-EXISTENT QUERY: '$testedQueryName'\n\n"
      unless $queryNameHash->{$testedQueryName};
    ## make sure we have a name and value for the param
  }
}

sub getQueryNameHash {
  my ($gbrowseConfig) = @_;

  my $qnh = {};
  my @qna;
  foreach my $module (@{$gbrowseConfig->{module}}) {
    foreach my $sqlQuery (@{$module->{sqlQuery}}) {
      push(@qna, $sqlQuery->{name}->[0]);
      $qnh->{$sqlQuery->{name}->[0]} = $sqlQuery;
    }
  }
  return ($qnh,\@qna);
}

sub getTestedQueryNames {
  my ($sanityConfig, $parentFeatureTests) = @_;

  my %testedNames;
  my $count=0;
  foreach my $test (@{$sanityConfig->{test}}) {
    $count++;
    die "test $count ($test->{name}) missing min\n" if $test->{min} eq "";
    die "test $count ($test->{name}) missing max\n" if $test->{max} eq "";
    $testedNames{$test->{name}} = 1;
    foreach my $param (@{$test->{param}}) {
      if ($param->{parentFeatureTest}) {
	$parentFeatureTests->{$param->{parentFeatureTest}} = 1;
      }
    }
  }
  foreach my $test (@{$sanityConfig->{test}}) {
    if ($parentFeatureTests->{$test->{name}}) {
      $parentFeatureTests->{$test->{name}} = {test => $test};
    }
  }
  return %testedNames;
}

sub getQueryParamNames {
  my ($sqlString) = @_;

  my %paramNames;
  while ($sqlString =~ /\$(\w+)/g){
    $paramNames{$1} = 1;
  }
  return keys %paramNames;
}

sub getDbHandle {
  my ($showDbInfo) = @_;

  my $c = new ApiCommonWebsite::Model::ModelConfig($model);

  my $dsn = $c->getDbiDsn();
  my $login = $c->getLogin();

  my $dbh = DBI->connect(
                $c->getDbiDsn, 
                $c->getLogin, 
                $c->getPassword,
                { PrintError => 1, RaiseError => 0}
                ) or die "Can't connect to the database: $DBI::errstr\n";
  $dbh->{LongReadLen} = 1000;
  $dbh->{LongTruncOk} = 1;
  print "db info:\n  dsn=$dsn\n  login=$login\n\n" if $showDbInfo;
  return $dbh;
}



sub runTests {
  my ($dbh, $queryNameHash, $sanityConfig, $failuresOnly, $skipTo, $stopAfter, $defaultParams, $parentFeatureTests, $sqlMode) = @_;

  my $sqlValues = &getSqlValues($dbh, $sanityConfig->{sqlValue});

  my $count = 0;
  my $passed = 0;
  my $failed = 0;
  my $runCount = 0;
  my $totalTime = 0;

  foreach my $test (@{$sanityConfig->{test}}) {
    $count++;
    next if ($count < $skipTo);
    last if ($count > $stopAfter);
    $runCount++;
    my $testString = &test2string($test);

    my ($parentFeatureId, $parentFeatureRowCount) =
      &findParentFeatureId($dbh, $test->{param}, $defaultParams, $sqlValues,
			   $parentFeatureTests);

    my $startTime = gettimeofday();
    my ($rowCount, $sqlString) = 
      &runSingleTest($dbh, $test, $defaultParams,
		     $sqlValues, $parentFeatureTests, $parentFeatureId);
    my $time = gettimeofday() - $startTime;
    $time = int($time * 10000)/10000;
    $totalTime += $time;
    my $multiplier = "";
    if ($parentFeatureId) {
      $multiplier = " ($time multiplied by $parentFeatureRowCount parent feature rows)";
      $time *= $parentFeatureRowCount;
    }
    if ($rowCount >= $test->{min} && $rowCount <= $test->{max}) {
      print "$time$multiplier PASSED $testString (returned $rowCount) [test: $count]\n\n"
	unless $failuresOnly;
      print "sql:\n$sqlString\n\n" if $sqlMode;
      $passed++;
    } else {
      $failed++;
      print "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n";
      print "$time FAILED $testString [test: $count] expected $test->{min} to $test->{max}.  got: $rowCount

sql:
$sqlString
";
      print "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n";
    }

  }
  print "
Ran $runCount tests
  $passed passed
  $failed failed
Total time: $totalTime
";
}
sub runSingleTest {
  my ($dbh, $test, $defaultParams, $sqlValues, $parentFeatureTests, $parentFeatureId) = @_;
  my $rawSqlString = $queryNameHash->{$test->{name}}->{sql}->[0];

  my $sqlString = &interpolateParams($rawSqlString, $defaultParams,
				     $test->{name},
				     $test->{param}, $sqlValues,
				     $parentFeatureId);
  my $stmt = $dbh->prepare($sqlString);
  $stmt->execute();
  my $rowCount = 0;
  my $parentFeatureTest = $parentFeatureTests->{$test->{name}};
  my $parentFeatureId;

  while (my $row = $stmt->fetchrow_hashref()) {
    $rowCount++;
    # if we have a feature_id, remember it in case there is a subfeature query
    # that might need it.
    $parentFeatureId = $row->{FEATURE_ID} if $rowCount == 1;
  }
  if ($parentFeatureTest) {
    $parentFeatureTest->{featureId} = $parentFeatureId;
    $parentFeatureTest->{rowCount} = $rowCount;
  }

  return ($rowCount, $sqlString);
}

sub findParentFeatureId {
  my ($dbh, $params, $defaultParams, $sqlValues, $parentFeatureTests) = @_;
  my $parentFeatureId;
  my $parentFeatureRowCount;

  foreach my $param (@$params) {
    next unless $param->{parentFeatureTest};
    my $parentTestStuff = $parentFeatureTests->{$param->{parentFeatureTest}};
    if (!$parentTestStuff->{featureId}) {
      print STDERR "(running test '$parentTestStuff->{test}->{name}' to get parent feature id)\n";
      &runSingleTest($dbh, $parentTestStuff->{test}, $defaultParams,
		     $sqlValues, $parentFeatureTests);
    }
    $parentFeatureId = $parentTestStuff->{featureId};
    $parentFeatureRowCount = $parentTestStuff->{rowCount};
  }
  return ($parentFeatureId, $parentFeatureRowCount);
}

sub getSqlValues {
  my ($dbh, $sqlValueElements) = @_;

  my $answer = {};
  foreach my $sqlValue (@$sqlValueElements) {
    my $sql = $sqlValue->{sql}->[0];
    my $stmt = $dbh->prepare($sql);
    $stmt->execute();
    my $rowCount;
    while (my @result = $stmt->fetchrow_array()) {
      $rowCount++;
      die ("sqlValue $sqlValue->{name} does not return 1 row ($rowCount)") unless $rowCount == 1;
      my $columnCount = scalar(@result);
      die ("sqlValue $sqlValue->{name} does not return 1 column ($columnCount)")
	unless $columnCount == 1;
      $answer->{$sqlValue->{name}} = $result[0];
    }
  }
  return $answer;
}

sub interpolateParams {
  my ($rawSqlString, $defaultParams, $testName, $params, $sqlValues,$parentFeatureId) = @_;

  my $sqlString = $rawSqlString;

  # first do explicit values
  foreach my $param (@$params) {
    my $macro = '\$' . $param->{name};
    my $val = $param->{value};
    if ($param->{parentFeatureTest}) {
      $val = $parentFeatureId;
      die("Can't find feature_id from parent test '$param->{parentFeatureTest}'\n") unless $val;
   }
    $val = &substituteSqlValue($val, $sqlValues);
    $sqlString =~ s/$macro/$val/g if $val;
  }

  # then defaults
  foreach my $paramName (keys %$defaultParams) {
    my $macro = '\$' . $paramName;
    my $val = $defaultParams->{$paramName}->{value};
    $val = &substituteSqlValue($val, $sqlValues);
    if ($sqlMode eq 'commented') {
      $sqlString =~ s/$macro/$val \/\* P_A_R_A_M$paramName \*\//g
    } else {
      $sqlString =~ s/$macro/$val/g
    }
  }

  foreach my $param (@$params) {
    my $macro = '\$' . $param->{name};
    die("Can't find value for param '$param->{name}' of test '$testName'\n") 
       if $sqlString =~ /$macro/;
  }

  $sqlString =~ s/P_A_R_A_M/\$/g;

  return $sqlString;
}

sub substituteSqlValue {
  my ($macroMaybe, $sqlValues) = @_;

  my $val = $macroMaybe;

  if ($macroMaybe =~ /\$\$(\S+)\$\$/) {
    $val = $sqlValues->{$1};
    die ("couldn't find sqlValue for macro '$macroMaybe'") unless $val;
  }

  return $val;
}


