#!/usr/bin/perl
use strict;
use Getopt::Long;

my ($threshold, $genepage, $width_filter, $time_filter, $sort_column, $plotOutputFile);
$sort_column=2;
&GetOptions('s=s' => \$threshold,
            'g' => \$genepage,
            'w=s' => \$width_filter,
            't=s' => \$time_filter,
            'c=s' => \$sort_column,
            'p=s' => \$plotOutputFile
            );


usage() unless $threshold;

my ($width_min, $width_max);
if ($width_filter) {
  ($width_min, $width_max) = split(/,\s*/, $width_filter);
}

my ($time_min, $time_max);
if ($time_filter) {
  ($time_min, $time_max) = split(/,\s*/, $time_filter);
  print "\nTime filter start: " . localtime($time_min) . " ($time_min)\n";
  print   "Time filter end:   " . localtime($time_max) . " ($time_max)\n" if $time_max;
  print "\n";
}

# QUERYTIME       Fri Mar 12 22:26:49 2010        1268450809.72195        v       Segment.pm      7.12     5792    alignment:dbEST
my $h;

if ($plotOutputFile) {
  open(P, ">$plotOutputFile") || die "Can't open plot output file '$plotOutputFile'\n";
}

my $min_absolute_time = 1000000000000000;
my $max_absolute_time = 0;
while(<STDIN>) {
  next unless /QUERYTIME/;
  next if /\=\=/;  # some lines in the log are mangled, with missing newlines
                   # the symptom is that the next log entry is mashed in
                   # these are delimited by ========, so dodge that
  next if ($genepage && !/GENEPAGE/);
  chomp;
  my ($qt, $timestamp, $absoluteTime, $tag, $module, $seconds, $width, $name) = split(/\t/);
  next if ($time_min && $absoluteTime < $time_min);
  next if ($time_max && $absoluteTime > $time_max);
  next if ($width_min && $width < $width_min);
  next if ($width_max && $width > $width_max);
  $min_absolute_time = $absoluteTime if $absoluteTime < $min_absolute_time;  # the first time we have included
  $max_absolute_time = $absoluteTime if $absoluteTime > $max_absolute_time;  # the latest time we have included

  if (!$h->{$name}) {
    $h->{$name} = [$name, 0, 0, 0, 0, 0];
  }
  $h->{$name}->[1] += $seconds;      # total secs
  $h->{$name}->[2] += 1;             # count
  if ($seconds > $threshold) {
    $h->{$name}->[3] += $seconds;    # total secs over threshold
    $h->{$name}->[4] += 1;           # count over threshold
  }
  $h->{$name}->[5] = $seconds if ($seconds > $h->{$name}->[5]); # max secs

  # we are generating a plot data file too
  if ($plotOutputFile) {
    print P "$absoluteTime\t$seconds\t$name\n";
  }
}

close(P) if ($plotOutputFile);

my @sorted = sort {$b->[$sort_column-1] <=> $a->[$sort_column-1]} values(%$h);


# name total_secs count avg_secs total_secs_over count_over  worst_secs
  print sprintf("%47s%12s%8s%10s%12s%8s%7s\n",('Name','TotSecs','#','AvgSecs','SlowSecs','Slow_#','Worst'));

foreach my $a (@sorted) {
  my $avg = $a->[1] / $a->[2];
  print sprintf("%47s%12.2f%8d%10.2f%12.2f%8d%7.2f\n",($a->[0],$a->[1],$a->[2],$avg,$a->[3],$a->[4],$a->[5]));
}

print "\nActual time start: " . localtime($min_absolute_time) . " ($min_absolute_time)\n";
print   "Actual time end:   " . localtime($max_absolute_time) . " ($max_absolute_time)\n\n";


sub usage {
  print STDERR "

Print a report summarizing the gbrowse slow query logs.

Takes one or more logs on standard input.

usage:  gbrowseSlowQueryReport -s secs [-g] [-w width_min[,length_max]] [-t starttime[,endtime]] [-c colnum] [-p plotOutputFile]

where:
  -s:  slowness threshold in seconds.  run times over secs are reported in Slow columns
  -g:  genepage only flag
  -w:  width filter
  -t:  time filter (use seconds since epoch, which is a column in gbrowse log)
  -c:  column to sort on (default is 2, the total time)
  -p:  optional output file: a tab delimited file to pass as input
        to wdkSlowQueryPlot.  Used to visualize the query durations over time.

";
  exit(1);
}
