<DAS>

<sanityTestInfo project="ToxoDB">
    <defaultParamValue name="name" value="TGME49_chrVI"/>
    <defaultParamValue name="parent_id" value="TGME49_039250"/>
    <defaultParamValue name="srcfeature_id" value="$$na_seq_id_VI$$"/>
    <defaultParamValue name="base_start" value="470000"/>
    <defaultParamValue name="rend" value="510000"/>
    <defaultParamValue name="dlm" value="|"/>

    <sqlValue name="na_seq_id_VI">
      <sql>
      select na_sequence_id from dots.VirtualSequence where source_id = 'TGME49_chrVI'
      </sql>
    </sqlValue>
    <sqlValue name="na_seq_id_Ib">
      <sql>
      select na_sequence_id from dots.VirtualSequence where source_id = 'TGME49_chrIb'
      </sql>
    </sqlValue>
    <sqlValue name="na_seq_id_X">
      <sql>
      select na_sequence_id from dots.VirtualSequence where source_id = 'TGME49_chrX'
      </sql>
    </sqlValue>
    <sqlValue name="na_seq_id_IX">
      <sql>
      select na_sequence_id from dots.VirtualSequence where source_id = 'TGME49_chrIX'
      </sql>
    </sqlValue>
    <sqlValue name="na_seq_id_scf_1107000999720">
      <sql>
      select na_sequence_id from dots.NaSequence where source_id = 'scf_1107000999720'
      </sql>
    </sqlValue>
    <sqlValue name="na_seq_id_scf_1107000999162">
      <sql>
      select na_sequence_id from dots.NaSequence where source_id = 'scf_1107000999162'
      </sql>
    </sqlValue>
    <sqlValue name="mass_spec_feature_id">
      <sql>
      select na_feature_id from dots.MassSpecFeature where rownum=1
      </sql>
    </sqlValue>
    <sqlValue name="similarity_id">
      <sql>
      select similarity_id from dots.SimilaritySpan where rownum=1
      </sql>
    </sqlValue>
</sanityTestInfo>


<sanityTestInfo project="CryptoDB">
    <defaultParamValue name="name" value="CM000435"/>
    <defaultParamValue name="srcfeature_id" value="$$na_seq_id_CM000435$$"/>
    <defaultParamValue name="base_start" value="39600"/>
    <defaultParamValue name="rend" value="70500"/>
    <defaultParamValue name="dlm" value=","/>

  <sqlValue name="na_seq_id_CM000435">
    <sql>
      select na_sequence_id from dots.nasequence where source_id = 'CM000435'
    </sql> 
  </sqlValue>

  <sqlValue name="na_seq_id_scf_23">
          <sql>
      select na_sequence_id from dots.nasequence where source_id = 'scf_23'
    </sql>
  </sqlValue>

  <sqlValue name="na_seq_id_CM000431">
          <sql>
      select na_sequence_id from dots.nasequence where source_id = 'CM000431'
    </sql>
  </sqlValue>

  <sqlValue name="na_feat_id_cgd7_230">
    <sql>
      select na_feature_id from dots.genefeature where source_id = 'cgd7_230'
    </sql> 
  </sqlValue>
</sanityTestInfo>


<sanityTestInfo project="TriTrypDB">
    <defaultParamValue name="name" value="Tb927_08_v4"/>
    <defaultParamValue name="srcfeature_id" value="$$na_seq_id_Tb927_08_v4$$"/>
    <defaultParamValue name="base_start" value="160000"/>
    <defaultParamValue name="rend" value="193000"/>
    <defaultParamValue name="dlm" value=","/>

    <sqlValue name="na_seq_id_Tb927_08_v4">
      <sql>
      select na_sequence_id from dots.externalnasequence where source_id = 'Tb927_08_v4'
      </sql>
    </sqlValue>
    <sqlValue name="na_feat_id_Tb927.8.620">
      <sql>
      select na_feature_id from dots.genefeature where source_id = 'Tb927.8.620'
     </sql>
    </sqlValue>
    <sqlValue name="na_feat_id_LmjF24_01_20050601_V5.2">
      <sql>
      select na_sequence_id from dots.nasequence where source_id = 'LmjF24_01_20050601_V5.2'
     </sql>
    </sqlValue>
    <sqlValue name="na_feat_id_LmjF01_01_20050601_5.2">
      <sql>
     select na_sequence_id from dots.nasequence where source_id = 'LmjF01_01_20050601_5.2' 
     </sql>
    </sqlValue>
    <sqlValue name="na_feat_id_TcChr10-S">
      <sql>
     select na_sequence_id from dots.nasequence where source_id = 'TcChr10-S'
     </sql>
    </sqlValue>
    <sqlValue name="na_feat_id_TcChr7-S">
      <sql>
     select na_sequence_id from dots.nasequence where source_id = 'TcChr7-S'
     </sql>
    </sqlValue>
</sanityTestInfo>


<sanityTestInfo project="PlasmoDB">
    <defaultParamValue name="name" value="Pf3D7_11"/>
    <defaultParamValue name="srcfeature_id" value="$$na_seq_id_Pf3D7_11$$"/>
    <defaultParamValue name="base_start" value="1278854"/>
    <defaultParamValue name="rend" value="1310722"/>
    <defaultParamValue name="dlm" value=","/>

    <sqlValue name="na_seq_id_Pf3D7_11">
      <sql>
      select na_sequence_id from dots.externalnasequence where source_id = 'Pf3D7_11'
      </sql>
    </sqlValue>
    <sqlValue name="na_seq_id_Pf3D7_09">
      <sql>
      select na_sequence_id from dots.externalnasequence where source_id = 'Pf3D7_09'
      </sql>
    </sqlValue>
    <sqlValue name="na_seq_id_Pf3D7_06">
      <sql>
      select na_sequence_id from dots.externalnasequence where source_id = 'Pf3D7_06'
      </sql>
    </sqlValue>
    <sqlValue name="na_seq_id_AABL01000313">
      <sql>
      select na_sequence_id from dots.externalnasequence where source_id = 'AABL01000313'
      </sql>
    </sqlValue>
</sanityTestInfo>

<sanityTestInfo project="GiardiaDB">
  <defaultParamValue name="name" value="CH991767"/>
  <defaultParamValue name="srcfeature_id" value="$$na_seq_id_CH991767$$"/>
  <defaultParamValue name="base_start" value="212601"/>
  <defaultParamValue name="rend" value="244949"/>
  <defaultParamValue name="dlm" value=","/>

  <sqlValue name="na_seq_id_CH991767">
    <sql>
      select na_sequence_id from dots.GeneFeature where source_id = 'GL50803_102438'
    </sql> 
  </sqlValue>
</sanityTestInfo>

<sanityTestInfo project="TrichDB">
  <defaultParamValue name="name" value="DS113983"/>
  <defaultParamValue name="srcfeature_id" value="$$na_seq_id_DS113983$$"/>
  <defaultParamValue name="base_start" value="0"/>
  <defaultParamValue name="rend" value="22000"/>
  <defaultParamValue name="dlm" value=","/>

  <sqlValue name="na_seq_id_DS113983">
    <sql>
      select na_sequence_id from dots.externalnasequence where source_id = 'DS113983'
    </sql> 
  </sqlValue>
  <sqlValue name="na_seq_id_DS123607">
    <sql>
      select na_sequence_id from dots.nasequence where source_id = 'DS123607'
    </sql>
  </sqlValue>
</sanityTestInfo>



<!--                        GUS.pm                        -->
<!-- This is the only query implemented by GUS.pm.        -->
<!-- It's call by get_feature_by_name subroutine.         -->

<module name="GUS.pm">
  <sqlQuery name="get_feature_by_name">
    <sql>
<![CDATA[
SELECT  
       ctg_name, feature_id, type, source, name, phase, parent_id,
       startm, end, strand
FROM (
SELECT -- trying to find genes by source_id
       nal.sequence_source_id ctg_name, 
       nal.na_feature_id feature_id, 
       'gene' type, 
       'annotation' source, 
       nal.feature_source_id name, 
       '' phase, 
       nal.na_sequence_id parent_id, 
       nal.start_min  startm, 
       nal.end_max end, 
       decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand
FROM   
       ApidbTuning.FeatureLocation nal,
       ApidbTuning.GeneId ga
WHERE  
       nal.feature_source_id = ga.gene and
       lower(ga.id) like lower('$name') and
       ga.unique_mapping = 1 and
       nal.is_top_level=1
UNION
SELECT   -- trying to find genes by product description ( at least 7 chars)
       gs.source_id ctg_name,
       gf.na_feature_id feature_id,
       'gene' type,
       'annotation' source,
       gf.source_id || ':  ' || gf.product name,
       '' phase,
       gs.na_sequence_id parent_id,
       ga.start_min startm,
       ga.end_max end,
       decode (ga.strand, 'forward', '+1', 'reverse', '-1', '.') strand
FROM
       dots.GeneFeature gf, ApidbTuning.GenomicSequence gs, ApidbTuning.GeneAttributes ga
WHERE
       ga.sequence_id = gs.source_id and
       gf.source_id = ga.source_id and
       length('$name') >= 7 and
       upper(ga.product) like upper('%$name%')
UNION
SELECT -- match a sequence source_id
       gs.source_id ctg_name,
       gs.na_sequence_id feature_id,
       so.term_name type,
       ed.name source, 
       gs.source_id, 
       '' phase, 
       null parent_id, 
       1 startm, gs.length end, '.' strand
FROM ApidbTuning.GenomicSequence gs, sres.SequenceOntology so,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     dots.NASequence nas
WHERE gs.lowercase_source_id
      in lower('$name')
  AND gs.sequence_ontology_id = so.sequence_ontology_id
  AND gs.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND gs.na_sequence_id = nas.na_sequence_id)
]]>
    </sql>
  </sqlQuery>
</module>


<!--                       Segment.pm                                 -->
<!-- Feature names are in the same format as the config - type:Source -->

<module name="Segment.pm">
  <sqlQuery name="new:Segment">
     <sql>
<![CDATA[
SELECT etn.na_sequence_id srcfeature_id, 
       1 startm, 
       etn.length end, 
       etn.source_id name, 
       'Sequence' type, 
       ' ' atts
FROM   ApidbTuning.SequenceAttributes etn, ApidbTuning.SequenceAlias sa
WHERE  etn.source_id = sa.source_id 
 and sa.lowercase_source_id = lower('$name') 
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="get_sequence">
    <sql>
<![CDATA[ 
SELECT ens.sequence 
FROM   DOTS.NASEQUENCE ens 
WHERE  ens.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="gene:annotation">
     <sql>
<![CDATA[
 SELECT
       ga.na_feature_id feature_id,
       'gene' type,
       'annotation' source,
       ga.source_id name,
       '.' score,
       ga.na_sequence_id parent_id,
       fl.start_min startm,
       fl.end_max end,
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=' || ga.product  || '$dlm' ||
       'soTerm=' || ga.so_term_name || '$dlm' ||
       'Contig=' || ga.sequence_id || '$dlm' ||
       'product=' || replace(ga.product,'''','&#146;') || decode(ga.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'taxon=' || ga.organism || '$dlm' ||
       'isDeprecated=' || ga.is_deprecated || '$dlm' ||
       'isPseudo=' || ga.is_pseudo
         as atts
FROM
       ApidbTuning.GeneAttributes ga,
       ApidbTuning.FeatureLocation fl
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.feature_type = 'GeneFeature'
  AND  fl.na_feature_id = ga.na_feature_id
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
ORDER BY 
       fl.start_min
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="piggyBac:TransposableElement" includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'piggyBac' type, 
       'TransposableElement' source, 
       nas.source_id name, 
       blat.score, 
       blat.target_na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=here to work around Feature.pm bug of splitting null atts' atts
FROM   DoTS.NASequence nas, 
       SRes.ExternalDatabaseRelease edr, 
       SRes.ExternalDatabase ed,
       DoTS.BlatAlignment blat 
WHERE  blat.query_na_sequence_id = nas.na_sequence_id 
   and edr.external_database_release_id = nas.external_database_release_id
   and ed.external_database_id = edr.external_database_id
   and ed.name = 'pfal3D7_PiggyBac_Clones_Adams_clonedInsertEnds_RSRC' 
   and blat.target_start <= $rend 
   and blat.target_end >= $base_start
   and blat.target_na_sequence_id = $srcfeature_id
ORDER BY 
   blat.target_start
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rum:intron" includeProjects="PlasmoDB,ToxoDB">
     <sql>
     <![CDATA[
      SELECT rum_intron_feature_id feature_id,
             'rum' type, 
             '$source' source, 
             rif.sample_name name, 
             score score, 
             na_sequence_id parent_id, 
             mapping_start startm, 
             mapping_end end, 
            'LOUR=' || rif.long_overlap_unique_reads || '$dlm' ||
            'SOUR=' || rif.short_overlap_unique_reads || '$dlm' ||
            'LONR=' || rif.long_overlap_nu_reads || '$dlm' ||
            'SONR=' || rif.short_overlap_nu_reads || '$dlm' ||
            'SpliceSignal=' || rif.standard_splice_signal || '$dlm' ||
            'NCSignal=' || rif.signal_not_canonical || '$dlm' ||
            'KnownINtron=' || rif.known_intron || '$dlm' ||
            'Canonical=' || rif.signal_not_canonical || '$dlm' ||
            'Scores=' || score || '$dlm' ||
            'Sample=' || sample_name atts
      FROM   apidb.RUMIntronFeature rif, 
             sres.externaldatabase edb,
             sres.externaldatabaserelease edbr 
      WHERE  rif.mapping_start <= $rend 
         AND rif.mapping_end >= $base_start 
         AND rif.na_sequence_id = $srcfeature_id
         AND mapping_end - mapping_start < 2000
         AND score > 1
         --AND known_intron = 1 
         AND rif.external_database_release_id = edbr.external_database_release_id 
         AND edb.external_database_id = edbr.external_database_id 
         AND edb.name $$edname$$
      ORDER BY rif.mapping_start, rif.sample_name
    ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rum:intronunified" includeProjects="PlasmoDB,ToxoDB,FungiDB">
     <sql>
     <![CDATA[
SELECT feature_id, type, source, parent_id, startm, end,
'Samples=' || listagg(samples, '|') within group (order by db_name) || '$dlm' ||
'Exps=' || listagg(db_name, '|') within group (order by db_name) || '$dlm' ||
'Subtrack=' || 
    CASE WHEN sum(sum_exp_score) > 100 THEN '100'
         WHEN sum(sum_exp_score) > 50 THEN '50'
         WHEN sum(sum_exp_score) > 20 THEN '20'
         WHEN sum(sum_exp_score) > 5 THEN '5'
         ELSE '1'
         END || '$dlm' ||
'Scores=' || listagg(scores, '|') within group (order by db_name) atts
FROM (
  SELECT rif.mapping_start || '_' || rif.mapping_end as feature_id,
         'rum' type, 
         '$source' source, 
         na_sequence_id parent_id, 
         mapping_start startm, 
         mapping_end end, 
         sum(score) as sum_exp_score,
         edb.name as db_name, 
         listagg(rif.sample_name, ',') within group (order by rif.sample_name) as samples,
         listagg(score, ',') within group (order by rif.sample_name) scores
  FROM   apidb.RUMIntronFeature rif, 
         sres.externaldatabase edb,
         sres.externaldatabaserelease edbr 
  WHERE  rif.mapping_start <= $rend 
     AND rif.mapping_end >= $base_start 
     AND rif.na_sequence_id = $srcfeature_id
     AND mapping_end - mapping_start < 2000
     AND score > 1
     --AND known_intron = 1 
     AND rif.external_database_release_id = edbr.external_database_release_id 
     AND edb.external_database_id = edbr.external_database_id 
  GROUP BY rif.mapping_start, mapping_end, edb.name, na_sequence_id
)
GROUP BY feature_id, type, source, parent_id,startm, end
ORDER BY startm
    ]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="alignment:ORFlength">
     <sql>
<![CDATA[
 SELECT na_feature_id feature_id, 
             'alignment' type, 
             '$source' source, 
             feature_source_id name, 
             '' score, 
             na_sequence_id parent_id, 
             start_min startm, 
             end_max end, 
             decode (is_reversed, 0, '+1', 1, '-1', '.') strand,
             'Length=' || (end_max-start_min+1)/3 atts
      FROM   ApidbTuning.FeatureLocation 
      WHERE  na_sequence_id = $srcfeature_id 
        AND  start_min <= $rend
        AND  end_max >= $base_start - 1 
        AND  feature_type='Miscellaneous'
        AND  end_max - start_min + 1 >= $$minLength$$
      ORDER BY start_min
]]>
    </sql>
  </sqlQuery>
  
    <sqlQuery name="alignment:ORF">
     <sql>
<![CDATA[
 SELECT na_feature_id feature_id, 
             'alignment' type, 
             'ORF' source, 
             feature_source_id name, 
             '' score, 
             na_sequence_id parent_id, 
             start_min startm, 
             end_max end, 
             decode (is_reversed, 0, '+1', 1, '-1', '.') strand,
             'Length=' || (end_max-start_min+1)/3 atts
      FROM   ApidbTuning.FeatureLocation 
      WHERE  na_sequence_id = $srcfeature_id 
        AND  start_min <= $rend
        AND  end_max >= $base_start - 1 
        AND  feature_type='Miscellaneous'
      ORDER BY start_min
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="alignment:EST">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id, 
       'alignment' type, 
       'EST' source, 
       est.accession name, 
       blat.score || '' score, 
       etn.na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Direction=' || est.p_end || ' prime' || '$dlm' ||
       'Primer=' || est.seq_primer || '$dlm' ||
       'Library=' || l.dbest_name || '$dlm' ||
       'Vector=' || l.vector || '$dlm' ||
       'Stage=' || l.stage || '$dlm' ||
       'PercentIdentity=' || blat.percent_identity atts 
FROM   
       ApidbTuning.BlatAlignmentLocation blat, 
       dots.ASSEMBLYSEQUENCE asbl, 
       dots.EST est, dots.library l,
       dots.NASEQUENCE etn
WHERE  
       est.library_id = l.library_id and
       blat.query_na_sequence_id = asbl.na_sequence_id and 
       blat.target_na_sequence_id = etn.na_sequence_id and 
       est.na_sequence_id = asbl.na_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       (blat.target_end - blat.target_start ) < 5000 and 
       blat.is_best_alignment = 1 and
       etn.na_sequence_id = $srcfeature_id 
ORDER BY blat.target_start asc, blat.score desc
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="match:WU_BLASTX">
     <sql>
<![CDATA[
select * from (
SELECT b.similarity_id feature_id, 'match' type, 'WU_BLASTX' source, 
       b.name, b.score, b.pvalue, b.na_sequence_id parent_id, 
       b.startm, b.end, b.strand, b.atts
FROM   
       ApidbTuning.Blastx b
WHERE  
       b.startm between $base_start and $rend and
       b.end between $base_start and $rend and       
       b.na_sequence_id = $srcfeature_id
ORDER BY 
       b.pvalue asc
) where rownum < 4000
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="alignment:DoTSAssemblies" excludeProjects="TrichDB">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id, 
       'alignment' type, 
       'DoTSAssemblies' source, 
       a.source_id name, 
       blat.score || '' score, 
       blat.target_na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'PercentIdentity=' || blat.percent_identity || '$dlm' ||
       'Count=' || a.number_of_contained_sequences atts 
FROM   
       ApidbTuning.BlatAlignmentLocation blat, 
       dots.Assembly a
WHERE  
       blat.query_na_sequence_id = a.na_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
--       (blat.target_end - blat.target_start ) < 5000 and 
       blat.is_best_alignment = 1 and
       blat.target_na_sequence_id = $srcfeature_id
ORDER BY 
       blat.target_start
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="Synteny:syntenyOrg" includeProjects="FungiDB">
     <sql>
<![CDATA[
select * from (
select
       gattr.na_feature_id feature_id,
       'Synteny' type, 
       '$source' source, 
       gattr.source_id name, 
       '.' score, 
       anch_left.synteny_id parent_id,
       CASE WHEN (syn.is_reversed = 1) 
         THEN anch_left.ref_loc - ((anch_left.syntenic_loc - (CASE WHEN fl.end_max > syn.b_end THEN syn.b_end ELSE fl.end_max END)) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
         ELSE anch_left.ref_loc + (((CASE WHEN fl.start_min < syn.b_start THEN syn.b_start ELSE fl.start_min END) - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))  
       END startm,
       CASE WHEN (syn.is_reversed = 1) 
         THEN anch_left.ref_loc - ((anch_left.syntenic_loc - (CASE WHEN fl.start_min < syn.b_start THEN syn.b_start ELSE fl.start_min END)) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
         ELSE anch_left.ref_loc + (((CASE WHEN fl.end_max > syn.b_end THEN syn.b_end ELSE fl.end_max END) - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))   
       END end,
       CASE WHEN (fl.is_reversed = syn.is_reversed) THEN 1 ELSE -1 END strand,
       'Note=' || gattr.product || decode(gattr.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'SOTerm=' || gattr.so_term_name || '$dlm' ||
       'SyntenyID=' || syn.synteny_id || '$dlm' ||
       'Contig=' || gattr.sequence_id || '$dlm' ||
       'IsPseudo=' || gattr.is_pseudo || '$dlm' ||
       'isDeprecated=' || gattr.is_deprecated || '$dlm' ||
       'Start=' || gattr.start_min || '$dlm' ||
       'End=' || gattr.end_max || '$dlm' ||
       'isReversed=' || gattr.is_reversed || '$dlm' ||
       'Truncated=' || CASE WHEN fl.end_max > syn.b_end THEN syn.b_end 
                           WHEN fl.start_min < syn.b_start THEN syn.b_start 
                           END || '$dlm' ||
       'Taxon=' || gattr.organism atts
FROM 
       apidb.synteny syn,
       apidb.syntenyAnchor anch_left,
       apidb.syntenyAnchor anch_right,
       apidbtuning.geneattributes gattr,
       apidbtuning.featurelocation fl
WHERE syn.a_na_sequence_id = $srcfeature_id
  AND gattr.organism = $$organism$$
  AND syn.a_na_sequence_id = $srcfeature_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start 
  AND anch_left.synteny_id = syn.synteny_id 
  AND anch_left.prev_ref_loc < $base_start 
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_left.ref_loc != anch_right.ref_loc
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND fl.na_sequence_id = syn.b_na_sequence_id 
  AND fl.feature_type = 'GeneFeature'
  AND gattr.na_feature_id = fl.na_feature_id
  AND (
       (syn.is_reversed = 0
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc + 1)>0
        AND anch_left.ref_loc + ((fl.start_min - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)) <= $rend 
        AND anch_left.ref_loc + ((fl.end_max - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)) >= $base_start
       ) 
       OR
       (syn.is_reversed = 1 
        AND abs(anch_left.syntenic_loc - anch_right.syntenic_loc - 1)>0
        AND anch_left.ref_loc + ((anch_left.syntenic_loc - fl.end_max) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc - 1)) <= $rend 
        AND anch_left.ref_loc + ((anch_left.syntenic_loc - fl.start_min) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc - 1)) >= $base_start 
       )
  )
  AND fl.start_min <= syn.b_end
  AND fl.end_max >= syn.b_start
) 
WHERE startm <= $rend
  AND end >= $base_start
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="gene:syntenyMC" excludeProjects="TrichDB">
     <sql>
<![CDATA[
select feature_id, type, source, name, score, parent_id, startm, end, strand, atts  from (
select
       gattr.na_feature_id feature_id,
       'gene' type, 
       'syntenyMC' source, 
       gattr.source_id name, 
       '.' score, 
       anch_left.synteny_id parent_id,
       apidb.compute_startm (syn.is_reversed, fl.start_min, fl.end_max,
                             anch_left.ref_loc, anch_right.ref_loc,
                             anch_left.syntenic_loc, anch_right.syntenic_loc,
                             syn.b_start, syn.b_end) startm,
       apidb.compute_end (syn.is_reversed, fl.start_min, fl.end_max,
                          anch_left.ref_loc, anch_right.ref_loc,
                          anch_left.syntenic_loc, anch_right.syntenic_loc,
                          syn.b_start, syn.b_end) end,
       CASE WHEN (fl.is_reversed = syn.is_reversed) THEN 1 ELSE -1 END strand,
       'Note=' || gattr.product || decode(gattr.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'SOTerm=' || gattr.so_term_name || '$dlm' ||
       'SyntenyID=' || syn.synteny_id || '$dlm' ||
       'Contig=' || gattr.sequence_id || '$dlm' ||
       'IsPseudo=' || gattr.is_pseudo || '$dlm' ||
       'isDeprecated=' || gattr.is_deprecated || '$dlm' ||
       'Start=' || gattr.start_min || '$dlm' ||
       'End=' || gattr.end_max || '$dlm' ||
       'isReversed=' || gattr.is_reversed || '$dlm' ||
       'Truncated=' || CASE WHEN fl.end_max > syn.b_end THEN syn.b_end 
                           WHEN fl.start_min < syn.b_start THEN syn.b_start 
                           END || '$dlm' ||
       'SynType=' || 'genes' ||  '$dlm' || 
       'Taxon=' || gattr.organism atts
FROM 
       apidb.synteny syn,
       apidb.syntenyAnchor anch_left,
       apidb.syntenyAnchor anch_right,
       ApidbTuning.GeneAttributes gattr,
       ApidbTuning.FeatureLocation fl
WHERE syn.a_na_sequence_id = $srcfeature_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start 
  AND anch_left.synteny_id = syn.synteny_id 
  AND anch_left.prev_ref_loc < $base_start 
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_left.ref_loc != anch_right.ref_loc
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND fl.na_sequence_id = syn.b_na_sequence_id 
  AND fl.feature_type = 'GeneFeature'
  AND gattr.na_feature_id = fl.na_feature_id
  AND (
       (syn.is_reversed = 0
        -- test that the divisor used in synteny scaling is nonzero. It's odd
        -- that this varies with is_reversed. But any changes must happen both
        -- here and in the PL/SQL
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc + 1)>0
        AND apidb.compute_startm (syn.is_reversed, fl.start_min, fl.end_max,
                                  anch_left.ref_loc, anch_right.ref_loc,
                                  anch_left.syntenic_loc, anch_right.syntenic_loc,
                                  syn.b_start, syn.b_end) <= $rend
        AND apidb.compute_end (syn.is_reversed, fl.start_min, fl.end_max,
                               anch_left.ref_loc, anch_right.ref_loc,
                               anch_left.syntenic_loc, anch_right.syntenic_loc,
                               syn.b_start, syn.b_end) >= $base_start
       ) 
       OR
       (syn.is_reversed = 1 
        -- test that the divisor used in synteny scaling is nonzero. It's odd
        -- that this varies with is_reversed. But any changes must happen both
        -- here and in the PL/SQL
        AND abs(anch_left.syntenic_loc - anch_right.syntenic_loc - 1)>0
        AND apidb.compute_startm (syn.is_reversed, fl.start_min, fl.end_max,
                                  anch_left.ref_loc, anch_right.ref_loc,
                                  anch_left.syntenic_loc, anch_right.syntenic_loc,
                                  syn.b_start, syn.b_end) <= $rend
        AND apidb.compute_end (syn.is_reversed, fl.start_min, fl.end_max,
                               anch_left.ref_loc, anch_right.ref_loc,
                               anch_left.syntenic_loc, anch_right.syntenic_loc,
                               syn.b_start, syn.b_end) >= $base_start
       )
  )
  AND fl.start_min <= syn.b_end
  AND fl.end_max >= syn.b_start
) 
WHERE startm <= $rend
  AND end >= $base_start
UNION
SELECT
       syn.synteny_id feature_id,
       'gene' type, 
       'syntenyMC' source, 
       b.source_id name, 
       '.' score, 
       syn.synteny_id parent_id, 
       CASE WHEN (is_reversed = 1) 
         THEN round(anch_left.ref_loc - ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1)))
         ELSE round(anch_left.ref_loc - ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)))
       END startm,
       CASE WHEN (is_reversed = 1) 
         THEN round(anch_left.ref_loc + ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1)))
         ELSE round(anch_left.ref_loc + ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)))
       END end, 
       decode(is_reversed, 0, +1, 1, -1, +1) strand,
       'RefStart=' || syn.a_start || '$dlm' ||
       'RefEnd=' || syn.a_end || '$dlm' ||
       'RefContigLength=' || a.length || '$dlm' ||
       'SynStart=' || syn.b_start || '$dlm' ||
       'SynEnd=' || syn.b_end || '$dlm' ||
       'ContigLength=' || b.length || '$dlm' ||
       'Contig=' || b.source_id || '$dlm' ||
       'Chromosome=' || b.chromosome || '$dlm' ||
        (CASE WHEN (b.chromosome is NOT NULL) 
             THEN (SELECT 'ChrColor=' || rcc.value || '$dlm' 
                  FROM apidb.rodentChrColors rcc 
                   WHERE b.chromosome = rcc.chromosome) 
             ELSE ''
             END) || 
       'ExtDBName=' || ed.name || '$dlm' ||
       'Taxon=' || b.organism || '$dlm' ||
       'SynType=' || 'contig' ||  '$dlm' ||
       'Scale=' || 
       CASE WHEN (is_reversed = 1) 
         THEN (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1)
         ELSE (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1) 
         END atts
FROM 
      apidb.synteny syn,
      apidb.syntenyAnchor anch_left,
      apidb.syntenyAnchor anch_right,
      ApidbTuning.SequenceAttributes a,
      ApidbTuning.SequenceAttributes b,
      sres.externaldatabaserelease edr,
      sres.externaldatabase ed
WHERE edr.external_database_id = ed.external_database_id
  AND syn.external_database_release_id = edr.external_database_release_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start
  AND syn.a_na_sequence_id = $srcfeature_id
  AND a.na_sequence_id = syn.a_na_sequence_id
  AND b.na_sequence_id = syn.b_na_sequence_id
  AND anch_left.synteny_id = syn.synteny_id
  AND anch_left.prev_ref_loc < $base_start
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc) > 1 
UNION
-- for: reference organism - gene
SELECT
       gattr.na_feature_id feature_id,
       'gene' type, 
       'syntenyMC' source, 
       gattr.source_id name, 
       '.' score, 
       gattr.na_sequence_id parent_id,
       gattr.start_min startm,
       gattr.end_max end,
       decode(is_reversed, 0, +1, 1, -1, +1) strand,
       'Note=' || gattr.product || decode(gattr.is_deprecated,1,' (deprecated)') || '$dlm' ||
       'SOTerm=' || gattr.so_term_name || '$dlm' ||
       'Contig=' || gattr.sequence_id || '$dlm' ||
       'IsPseudo=' || gattr.is_pseudo || '$dlm' ||
       'isDeprecated=' || gattr.is_deprecated || '$dlm' ||
       'Start=' || gattr.start_min || '$dlm' ||
       'End=' || gattr.end_max || '$dlm' ||
       'isReversed=' || gattr.is_reversed || '$dlm' ||
       'SynType=' || 'genes' ||  '$dlm' || 
       'Taxon=' || gattr.organism atts
FROM 
       ApidbTuning.GeneAttributes gattr
WHERE gattr.na_sequence_id = $srcfeature_id
  AND start_min <= $rend
  AND end_max >= $base_start
UNION
-- for: reference organism - span
SELECT
        na_sequence_id feature_id,
        'gene' type, 
        'syntenyMC' source, 
        source_id name, 
        '.' score, 
        null parent_id,
        round($base_start) startm,
        round($rend) end, 
        0 strand,
       'RefStart=' || $base_start || '$dlm' ||
       'RefEnd=' || $rend || '$dlm' ||
       'RefContigLength=' || length || '$dlm' ||
       'SynStart=' || $base_start || '$dlm' ||
       'SynEnd=' || $rend || '$dlm' ||
       'ContigLength=' || length || '$dlm' ||
        'Contig=' || source_id || '$dlm' ||
        'Chromosome=' || chromosome || '$dlm' ||
         (CASE WHEN (chromosome is NOT NULL) 
              THEN (SELECT 'ChrColor=' || rcc.value || ';;' 
                   FROM apidb.rodentChrColors rcc 
                    WHERE sa.chromosome = rcc.chromosome) 
              ELSE ''
              END) || 
        'ExtDBName=' || database_name || '$dlm' ||
        'SynType=' || 'contig' ||  '$dlm' ||
  'Scale=1' ||  '$dlm' ||
        'Taxon=' || organism atts
 FROM 
       ApidbTuning.SequenceAttributes sa
 WHERE  na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="lowcomplexity:dust">
     <sql>
<![CDATA[
SELECT
       lc.na_feature_id feature_id,
       'lowcomplexity' type, 
       'dust' source, 
       lc.name name, 
       '.' score, 
       lc.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=here to work around Feature.pm bug of splitting null atts' atts
FROM 
       ApidbTuning.FeatureLocation fl, dots.LowComplexityNAFeature lc
WHERE
       fl.feature_type = 'LowComplexityNAFeature' and
       fl.start_min <= $rend and 
       fl.end_max >= $base_start and 
       fl.na_sequence_id = $srcfeature_id and
       fl.na_feature_id = lc.na_feature_id
ORDER BY 
       fl.start_min
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="match:TGI" excludeProjects="TriTrypDB,CryptoDB,GiardiaDB,TrichDB">
    <testParamValues project="ToxoDB">
      <param name="srcfeature_id" value="$$na_seq_id_scf_1107000999720$$"/>
      <param name="rend" value="70824"/>
      <param name="base_start" value="66116"/>
    </testParamValues>
    <testParamValues project="PlasmoDB">
      <param name="srcfeature_id" value="928098"/>
      <param name="rend" value="50"/>
      <param name="base_start" value="1"/>
    </testParamValues>
     <sql>
<![CDATA[
SELECT
       sim.similarity_id feature_id,
       'match' type, 
       'TGI' source, 
       query.source_id name, 
       (sim.number_positive / sim.total_match_length) score, 
       sim.subject_id    parent_id, 
       sim.min_subject_start startm, 
       sim.max_subject_end   end, 
       decode(sim.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=' || query.description || '$dlm' ||
       'TGI=' || edb.name || '$dlm' ||
       'TGIver=' || edbr.version || '$dlm' ||
       'TGISpecies=' || edb.name atts
FROM 
       dots.similarity sim,
       dots.externalnasequence query,
       sres.externaldatabase edb,
       sres.externaldatabaserelease edbr
WHERE  sim.min_subject_start <= $rend and
       sim.max_subject_end >= $base_start and
       sim.subject_id = $srcfeature_id and
       query.na_sequence_id = sim.query_id and
       query.external_database_release_id = edbr.external_database_release_id and
       edb.external_database_id = edbr.external_database_id and 
       edb.name in ('TgGI','Pfalciparum_chromosomes_RSRC','Pvivax_contigsGB_RSRC','Pberghei_chromosomes_RSRC','Pyoelii_Contigs_RSRC')
ORDER BY 
       sim.min_subject_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="SAGE:3-5prime" excludeProjects="CryptoDB,TrichDB,TriTrypDB">
     <sql>
<![CDATA[
SELECT distinct * from
(
SELECT fl.na_feature_id as feature_id,
       'SAGE' type, 
       '3-5prime' source, 
       sta.source_id name, 
       fl.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'SourceID=' || sta.feature_source_id || '$dlm' ||
       'Sequence=CATG' || staa.sequence || '$dlm' ||
       'Occurrence=' || staa.occurrence atts
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SageTagAnalysisAttributes staa,
       ApidbTuning.SageTagAttributes sta
WHERE  fl.feature_type ='SAGETagFeature'
  AND  fl.na_sequence_id = $srcfeature_id 
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  fl.na_feature_id = sta.na_feature_id
  AND  to_number(fl.feature_source_id) = staa.composite_element_id
)
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="SAGE:3-5prime" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
SELECT distinct * from
(
SELECT fl.na_feature_id as feature_id,
       'SAGE' type, 
       '3-5prime' source, 
       sta.source_id name, 
       fl.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'SourceID=' || sta.feature_source_id || '$dlm' ||
       'Sequence=CATG' || staa.sequence || '$dlm' ||
       'Occurrence=' || staa.occurrence atts
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SageTagAnalysisAttributes staa,
       ApidbTuning.SageTagAttributes sta
WHERE  fl.feature_type ='SAGETagFeature'
  AND  fl.na_sequence_id = $srcfeature_id 
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  fl.na_feature_id = sta.na_feature_id
  AND  staa.library_name in ('procyclic_gambiense', 'bloodstream_gambiense') 
  AND  to_number(fl.feature_source_id) = staa.composite_element_id
)
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="MicroArrayProbes:expressionH"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
SELECT $srcfeature_id as feature_id,
       'MicroArrayProbes' as type, 
       '$source'       as source,
       $srcfeature_id as parent_id,
       $base_start       as startm,
       $rend             as end 
FROM   dual 
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="MicroArrayProbes:expressionD" includeProjects="PlasmoDB,ToxoDB,TriTrypDB">
    <testParamValues project="PlasmoDB">
      <param name="srcfeature_id" value="$$na_seq_id_Pf3D7_06$$"/>
      <param name="base_start" value="469864"/> 
      <param name="rend" value="470011"/> 
    </testParamValues>
    <sql>   
<![CDATA[
SELECT fl.na_feature_id as feature_id,
       'MicroArrayProbes' type, 
       '$source' source, 
       fl.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'SourceId='   || fl.feature_source_id || '$dlm'
        as atts
FROM   ApidbTuning.FeatureLocation fl, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
WHERE  edr.external_database_id = ed.external_database_id
  AND  edr.external_database_release_id=fl.external_database_release_id
  AND  fl.feature_type = 'ArrayElementFeature'
  AND  ed.name = $$edname$$
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  fl.na_sequence_id = $srcfeature_id]]>
     </sql>
  </sqlQuery>
  


  <sqlQuery name="NextGenSeq:coverage"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
    SELECT $$sample$$ as feature_id,
          'NextGenSeq'        as type, 
          '$source'          as source,
           $base_start        as startm,
           $rend              as end 
  FROM   dual 
       ]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="NextGenSeq:coverageRatio"  includeProjects="TriTrypDB,PlasmoDB">
     <sql>
       <![CDATA[
    SELECT $$numSample$$ as feature_id,
          'NextGenSeq'        as type, 
          '$source'          as source,
           $base_start        as startm,
           $rend              as end 
  FROM   dual 
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="DGE:coverage"  includeProjects="TriTrypDB">
     <sql>
       <![CDATA[
    SELECT $$sample$$  as feature_id,
          'DGE'        as type, 
          '$source'    as source,
           $base_start as startm,
           $rend       as end 
    FROM   dual 
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="DGE:coverageSubtracks" includeProjects="TriTrypDB">
     <sql>
       <![CDATA[
    SELECT a.name  as feature_id,
          'DGE'        as type, 
          '$source'    as source,
           $base_start as startm,
           $rend       as end,
           'library=' || a.name as atts
    FROM rad.assay a
       ]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="NextGenSeq:coverageCombNormGB2"  includeProjects="TriTrypDB,PlasmoDB">
    <sql>
       <![CDATA[
SELECT ext_db_name || '_' || sample as feature_id,
       'NextGenSeq'  as type, 
       '$source'     as source,
       $base_start  as startm,
       $rend        as end,
       'sample=' || sample as atts
FROM apidbtuning.NextGenSeqStats
WHERE ext_db_name = $$edname$$
        ]]>
        </sql>
  </sqlQuery>

  <sqlQuery name="NextGenSeq:coverageLog"  includeProjects="TriTrypDB">
     <sql>
       <![CDATA[
    SELECT $$sample$$   as feature_id,
          'NextGenSeq'  as type, 
          '$source'     as source,
           $base_start  as startm,
           $rend        as end  
    FROM   dual 
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="NextGenSeq:coverageLogSubtracks"  includeProjects="PlasmoDB,ToxoDB,TriTrypDB,CryptoDB,FungiDB">
     <sql>
       <![CDATA[
select  distinct $$edname$$ || '_' || c.sample || '_' || $$subtrackField$$ as feature_id,
       'NextGenSeq'  as type, 
       '$source'     as source,
       $base_start  as startm,
       $rend        as end,
       'subtrackField=' || $$subtrackField$$ || '$dlm' || 'sample=' || c.sample as atts
from APIDB.nextgenseqcoverage c, SRES.externaldatabaserelease r, sres.externaldatabase d
where c.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and c.mapping_start <= $rend
and c.mapping_end >= $base_start
and c.na_sequence_id = $srcfeature_id
and d.name $$operator$$ $$edname$$
       ]]>
    </sql>
  </sqlQuery>


      <sqlQuery name="splice:curated" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
SELECT 
       ra.nextgenseq_align_id feature_id,
       'splice' type,
       'curated' source,
       ra.na_sequence_id as parent_id, 
       CASE WHEN ra.strand = '+' THEN ra.end_a + 1 ELSE ra.start_a - 1 END as startm, 
       CASE WHEN ra.strand = '+' THEN ra.end_a + 1 ELSE ra.start_a - 1 END as end, 
       ra.query_id as name, ra.strand||'1' as strand, 
       'genome_matches=' || ra.genome_matches || '$dlm' ||
       'count='|| ra.intron_size || '$dlm' ||
       'utr_length='|| ra.end_b || '$dlm' || 
       'sample='|| ra.sample || '$dlm' || 
       'gene_id=' || REGEXP_REPLACE(ra.query_id,'(\-\d+\-?\*?\(\))','') atts
FROM  apidb.nextgenseq_align ra, sres.externaldatabase d, sres.externaldatabaserelease rel
WHERE d.name = 'Tbrucei_RNASeq_Splice_Leader_And_Poly_A_Sites_George_Cross_RSRC'
 AND  rel.external_database_id = rel.external_database_id
 AND  ra.external_database_release_id = rel.external_database_release_id
 AND  ra.na_sequence_id = $srcfeature_id
 AND  ra.sample = 'curated_long_splice'
 AND  ra.start_a >= $base_start 
 AND  ra.end_a <= $rend
]]>
    </sql>
  </sqlQuery>

      <sqlQuery name="polya:curated" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
SELECT 
       ra.nextgenseq_align_id feature_id,
       'polya' type,
       'curated' source,
       ra.na_sequence_id as parent_id, 
       CASE WHEN ra.strand = '+' THEN ra.start_a - 1 ELSE ra.end_a + 1 END as startm, 
       CASE WHEN ra.strand = '+' THEN ra.start_a - 1 ELSE ra.end_a + 1 END as end, 
       ra.query_id as name, ra.strand||'1' as strand, 
       'genome_matches=1' || '$dlm' ||
       'count='|| ra.intron_size || '$dlm' ||
       'utr_length='|| ra.end_b || '$dlm' || 
       'sample='|| ra.sample || '$dlm' || 
       'gene_id=' || REGEXP_REPLACE(ra.query_id,'(\-\d+\-?\*?\(\))','') atts
FROM  apidb.nextgenseq_align ra, sres.externaldatabase d, sres.externaldatabaserelease rel
WHERE d.name = 'Tbrucei_RNASeq_Splice_Leader_And_Poly_A_Sites_George_Cross_RSRC'
 AND  rel.external_database_id = rel.external_database_id
 AND  ra.external_database_release_id = rel.external_database_release_id
 AND  ra.na_sequence_id = $srcfeature_id
 AND  ra.sample = 'curated_long_polyA'
 AND  ra.start_a >= $base_start 
 AND  ra.end_a <= $rend
]]>
    </sql>
  </sqlQuery>

      <sqlQuery name="splice:alignseq" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
SELECT min(feature_id) as feature_id, parent_id, startm, startm as end,
        'splice' type, 'alignseq' source,
        CASE WHEN strand = '+1' THEN substr(max(name),3,length(max(name))-2) 
          ELSE substr(max(name),0,length(max(name))-2) END as name, 
        strand,
        'genome_matches='||min(genome_matches) || '$dlm' ||
        'sample='||sample || '$dlm' ||
        'count='||count(*) atts
FROM
  (SELECT ra.nextgenseq_align_id feature_id,
         ra.na_sequence_id as parent_id, 
         CASE WHEN strand = '+' THEN ra.start_a + 2 ELSE ra.end_a - 2 END as startm, 
         ra.query_id name, ra.strand||'1' as strand,
         ra.genome_matches,ra.sample
  FROM  apidb.nextgenseq_align ra, sres.externaldatabase d, sres.externaldatabaserelease rel
  WHERE d.name = 'Tbrucei_RNASeq_Splice_Leader_And_Poly_A_Sites_George_Cross_RSRC'
   AND  rel.external_database_id = rel.external_database_id
   AND  ra.external_database_release_id = rel.external_database_release_id
   AND  ra.na_sequence_id = $srcfeature_id
   AND  ra.sample = 'raw_splice'
   AND  ra.start_a >= $base_start
   AND  ra.end_a <= $rend )
GROUP BY parent_id,sample,strand,startm
]]>
    </sql>
  </sqlQuery>

      <sqlQuery name="polya:alignseq" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
SELECT min(feature_id) as feature_id, parent_id, startm, startm as end,
        'polya' type, 'alignseq' source,
        max(name) as name, 
        strand,
        'genome_matches='||min(genome_matches) || '$dlm' ||
        'count='||count(*) atts
FROM
  (SELECT ra.nextgenseq_align_id feature_id, 
         ra.na_sequence_id as parent_id, 
         CASE WHEN strand = '+' THEN ra.end_a ELSE ra.start_a END as startm, 
         ra.query_id name, ra.strand||'1' as strand,
         ra.genome_matches
  FROM  apidb.nextgenseq_align ra, sres.externaldatabase d, sres.externaldatabaserelease rel
  WHERE d.name = 'Tbrucei_RNASeq_Splice_Leader_And_Poly_A_Sites_George_Cross_RSRC'
   AND  rel.external_database_id = rel.external_database_id
   AND  ra.external_database_release_id = rel.external_database_release_id
   AND  ra.sample = 'raw_polyA'
   AND  ra.start_a >= $base_start
   AND  ra.end_a <= $rend)
GROUP BY parent_id,strand,startm
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="domain:spliceSites" includeProjects="TriTrypDB">
    <sql>
<![CDATA[
SELECT 
       splice_site_feature_id feature_id,
       'domain' type,
       '$source' as source,
       location as startm, location as end, 
       CASE WHEN (NOT dist_to_cds = utr_len) 
               THEN  source_id || '-' ||  utr_len || '*(' || count_per_million || ')' || ' Alternate CDS Start'
            WHEN (dist_to_cds = utr_len AND within_cds=0) THEN  source_id || '-' || utr_len || '(' || count_per_million || ')'
            ELSE  source_id || '-' ||  'within gene' || '(' || count_per_million || ')' END AS name, 
       strand as strand, 
       'sample_name='|| sample_name || '$dlm' ||
       'count_per_mill='|| count_per_million || '$dlm' ||
       'is_unique='|| is_unique || '$dlm' || 
       'is_dominant='|| is_dominant || '$dlm' || 
       'avg_mismatches='|| avg_mismatches || '$dlm' || 
       'gene_id='|| source_id || ';;' || 
       'utr_length='|| utr_len atts
FROM (
 SELECT 
       distinct ssf.splice_site_feature_id, ssf.location, ssf.strand,
       ssf.sample_name, ssf.count_per_million, ssf.is_unique, ssf.avg_mismatches,
       gtable.source_id, gtable.utr_len, gtable.is_dominant, gtable.dist_to_cds, gtable.within_cds
 FROM  apidb.spliceSiteFeature ssf
 LEFT JOIN (SELECT source_id , sample_name, location, strand, is_dominant, count,
          dist_to_first_atg  AS utr_len, dist_to_cds, within_cds
   FROM Apidb.SpliceSiteGenes 
   WHERE na_sequence_id = $srcfeature_id
   AND location >=$base_start
   AND location <=$rend
   ) gtable
  ON (ssf.sample_name = gtable.sample_name AND ssf.location = gtable.location AND ssf.strand=gtable.strand)
 WHERE ssf.na_sequence_id = $srcfeature_id
   AND ssf.location >= $base_start
   AND ssf.location <= $rend
   AND ssf.type = $$type$$
   AND ssf.sample_name $$sample$$
   AND ssf.external_database_release_id in
     (SELECT external_database_release_id 
        FROM sres.externaldatabase ed, sres.externalDatabaseRelease edr
       WHERE ed.external_database_id = edr.external_database_id
         AND ed.name $$edName$$ )
   AND NOT (gtable.count=1 AND gtable.is_dominant is null)
   )
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="domain:polyASites" includeProjects="TriTrypDB">
    <sql>
<![CDATA[
SELECT 
       splice_site_feature_id feature_id,
       'domain' type,
       '$source' as source,
       location as startm, location as end, 
       CASE WHEN (source_id IS NULL) THEN ' (' || count_per_million || ')'
           WHEN (utr_len >0) THEN  source_id || '-' ||  utr_len || '(' || count_per_million || ')'
            ELSE  source_id || '-' ||  'within gene' || '(' || count_per_million || ')' END AS name, 
       strand as strand, 
       'sample_name='|| sample_name || '$dlm' ||
       'count_per_mill='|| count_per_million || '$dlm' ||
       'is_unique='|| is_unique || '$dlm' || 
       'is_dominant='|| is_dominant || '$dlm' || 
       'avg_mismatches='|| avg_mismatches || '$dlm' || 
       'gene_id='|| source_id || ';;' || 
       'utr_length='|| utr_len atts
FROM (
 SELECT 
       distinct ssf.splice_site_feature_id, ssf.location, ssf.strand,
       ssf.sample_name, ssf.count_per_million, ssf.is_unique, ssf.avg_mismatches,
       gtable.source_id, gtable.utr_len, gtable.is_dominant FROM  apidb.spliceSiteFeature ssf
 LEFT JOIN (SELECT source_id , sample_name, location, strand, is_dominant, count,
          CASE WHEN (within_cds=1) THEN (-1)*dist_to_cds ELSE dist_to_cds END AS utr_len
         FROM APIDB.polyagenes
   WHERE na_sequence_id = $srcfeature_id
   AND location >= $base_start
   AND location <= $rend
   ) gtable
  ON (ssf.sample_name = gtable.sample_name AND ssf.location = gtable.location AND ssf.strand=gtable.strand)
 WHERE ssf.na_sequence_id = $srcfeature_id
   AND ssf.location >= $base_start
   AND ssf.location <= $rend
   AND ssf.sample_name $$sample$$
   AND ssf.external_database_release_id in
     (SELECT external_database_release_id 
        FROM sres.externaldatabase ed, sres.externalDatabaseRelease edr
       WHERE ed.external_database_id = edr.external_database_id
         AND ed.name $$edName$$ )
   AND NOT (gtable.count=1 AND gtable.is_dominant is null)
   )
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="domain:MassSpecPeptide">
     <sql>
<![CDATA[
SELECT 
       msf.na_feature_id feature_id,
       'domain' type,
       '$source' source,
       x.parent_id, 
       startm, 
       end,
       msf.source_id name, x.strand,
       'Description=' || msf.description || '$dlm' ||
       'Count=' || match_count || '$dlm' ||
       'ExtDbName=' || ed_name || '$dlm' ||
       'Experiment=' || experiment  || '$dlm' ||
       'Sample=' || sample  || '$dlm' ||
       'PepSeq=' || substr(aas.sequence, aal.start_min, aal.end_max - aal.start_min + 1) || '$dlm' ||
       'SOTerm=' || fs.term_name || '$dlm' ||
       'Color=' || color atts
FROM  
(SELECT count(*) as match_count, 
       min(msf.na_feature_id) as feature_id,
       nal.na_sequence_id parent_id,
       nal.start_min startm,
       nal.end_max end,
       decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand,
       ed.name||'|'||mss.sample_file as ed_name,
       mst.experiment as experiment,
       mst.sample as sample,
       mst.html_color as color
FROM  dots.massspecfeature msf,
      apidb.massspecsummary mss,
      ApidbTuning.FeatureLocation nal,
      sres.externaldatabaserelease edr,
      sres.externaldatabase ed,
      ApidbTuning.MassSpecTerms mst
WHERE msf.na_feature_id = nal.na_feature_id
 AND  nal.na_sequence_id = $srcfeature_id
 AND  nal.start_min >= $base_start
 AND  nal.end_max <= $rend
 AND  msf.external_database_release_id = edr.external_database_release_id
 and  mss.mass_spec_summary_id = msf.source_id
 AND  ed.name $$edName$$
 AND  (ed.name = mst.internal_id or mst.internal_id = ed.name||'|'||mss.sample_file)
 AND  edr.external_database_id = ed.external_database_id
GROUP BY ed.name,mst.experiment,mss.sample_file,mst.sample,mst.html_color,nal.na_sequence_id,nal.is_reversed,nal.start_min,nal.end_max) x,
      dots.massspecfeature msf,
      dots.translatedaafeature taaf,
      ApidbTuning.FeatureSo fs,
      dots.aasequence aas, 
      dots.aalocation aal
WHERE msf.na_feature_id = x.feature_id
 AND  taaf.aa_sequence_id = msf.aa_sequence_id    
 AND  aal.aa_feature_id = msf.aa_feature_id
 AND  aas.aa_sequence_id = taaf.aa_sequence_id
 AND  taaf.na_feature_id = fs.na_feature_id
]]>
    </sql>
  </sqlQuery>
  


  <sqlQuery name="domain:OrfMassSpecPeptide">
     <sql>
<![CDATA[
SELECT 
       msf.na_feature_id feature_id,
       'domain' type,
       '$source' source,
       x.parent_id, 
       startm, 
       end,
       msf.source_id name, x.strand,
       'Description=' || msf.description || '$dlm' ||
       'Count=' || match_count || '$dlm' ||
       'ExtDbName=' || ed_name || '$dlm' ||
       'Experiment=' || experiment  || '$dlm' ||
       'Sample=' || sample  || '$dlm' ||
       'PepSeq=' || substr(aas.sequence, aal.start_min, aal.end_max - aal.start_min + 1) || '$dlm' ||
       'SOTerm=' || fs.term_name || '$dlm' ||
       'Color=' || color atts
FROM  
(SELECT count(*) as match_count, 
       min(msf.na_feature_id) as feature_id,
       nal.na_sequence_id parent_id,
       nal.start_min startm,
       nal.end_max end,
       decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand,
       ed.name||'|'||mss.sample_file as ed_name,
       mst.experiment as experiment,
       mst.sample as sample,
       mst.html_color as color
FROM  dots.massspecfeature msf,
      apidb.massspecsummary mss,
      ApidbTuning.FeatureLocation nal,
      sres.externaldatabaserelease edr,
      sres.externaldatabase ed,
      ApidbTuning.MassSpecTerms mst
WHERE msf.na_feature_id = nal.na_feature_id
 AND  nal.na_sequence_id = $srcfeature_id
 AND  nal.start_min >= $base_start
 AND  nal.end_max <= $rend
 AND  msf.external_database_release_id = edr.external_database_release_id
 and  mss.mass_spec_summary_id = msf.source_id
 AND  (ed.name = mst.internal_id or mst.internal_id = ed.name||'|'||mss.sample_file)
 AND  edr.external_database_id = ed.external_database_id
GROUP BY ed.name,mst.experiment,mss.sample_file,mst.sample,mst.html_color,nal.na_sequence_id,nal.is_reversed,nal.start_min,nal.end_max) x,
      dots.massspecfeature msf,
      dots.translatedaafeature taaf,
      ApidbTuning.FeatureSo fs,
      dots.aasequence aas, 
      dots.aalocation aal
WHERE msf.na_feature_id = x.feature_id
 AND  taaf.aa_sequence_id = msf.aa_sequence_id    
 AND  aal.aa_feature_id = msf.aa_feature_id
 AND  aas.aa_sequence_id = taaf.aa_sequence_id
 AND  taaf.na_feature_id = fs.na_feature_id
 AND  fs.term_name = 'ORF'
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="domain:UnifiedMassSpecPeptides">
      <sql>
<![CDATA[
 SELECT x.feature_id,
        'domain' type,
        'UnifiedMassSpecPeptides' source,
        x.parent_id, startm, end,
        source_name, strand,
        'SCount=' || count  || '$dlm' ||
        'Key=' || experiment_key ||'|'|| sample_key || '$dlm' ||
        'Experiment=' || experiment  || '$dlm' ||
        'Sample=' ||  sample  || '$dlm' ||
        'PepSeq=' || substr(aas.sequence, aal.start_min, aal.end_max - aal.start_min + 1) atts
FROM  (
      select count (*) as count,
             min(msf.na_feature_id) as feature_id,
             enas.na_sequence_id as parent_id,
             msf.source_id as source_name,
             nal.start_min startm,
             nal.end_max end,
             decode (nal.is_reversed, 0, '+1', 1, '-1', '.') as strand,
             mss.sample_file as sample_key,
             ed.name as experiment_key,
             mst.experiment as experiment,
             mst.sample
      from
      dots.massSpecFeature msf,
      ApidbTuning.FeatureLocation nal,
      dots.naSequence enas,
      apidb.massSpecSummary mss,
      sres.externalDatabaseRelease edr,
      sres.externalDatabase ed,
      dots.translatedAaFeature taaf,
      APIDBTUNING.massspecterms mst,
      dots.aaSequence aas,
      dots.aaLocation aal
WHERE msf.na_feature_id = nal.na_feature_id
 AND  nal.na_sequence_id = $srcfeature_id
 AND  enas.na_sequence_id = $srcfeature_id
 AND  nal.start_min >= $base_start
 AND  nal.end_max <= $rend
 AND  taaf.aa_sequence_id = msf.aa_sequence_id    
 AND  aal.aa_feature_id = msf.aa_feature_id
 AND  aas.aa_sequence_id = to_number(msf.aa_sequence_id)
 and  msf.source_id = mss.mass_spec_summary_id
 AND  msf.external_database_release_id = edr.external_database_release_id
 AND  edr.external_database_id = ed.external_database_id
 and  (mst.internal_id = ed.name||'|'||mss.sample_file or mst.internal_id = ed.name)
Group by     ed.name,
             mst.experiment,
             mss.sample_file,
             mst.sample,
             enas.na_sequence_id,
             msf.source_id,
             nal.start_min,
             nal.end_max,
             nal.is_reversed
) x,
      dots.massspecfeature msf,
      dots.translatedaafeature taaf,
      dots.aasequence aas,
      dots.aalocation aal
WHERE msf.na_feature_id = x.feature_id
 AND  taaf.aa_sequence_id = msf.aa_sequence_id    
 AND  aal.aa_feature_id = msf.aa_feature_id
 AND  aas.aa_sequence_id = taaf.aa_sequence_id

]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="UnifiedMassSpecPeptides:density">
   <sql>
<![CDATA[
SELECT etn.na_sequence_id feature_id,
       'UnifiedMassSpecPeptides' type,
       'density' source
FROM   dots.NASEQUENCE etn
WHERE  etn.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="alignment:BLAT">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id, 
       'alignment' type, 
       'BLAT' source, 
       est.accession name, 
       blat.score || '' score, 
       blat.query_na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand, 
        'PercentIdentity=' || blat.percent_identity  || '$dlm' ||
       'Library=' || l.dbest_name  || '$dlm' atts 
FROM   
       ApidbTuning.BlatAlignmentLocation blat, 
       dots.Est est, 
       dots.ExternalNASequence estseq,
       dots.Library l,
       sres.SequenceOntology so
WHERE  
       blat.query_na_sequence_id = est.na_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       (blat.target_end - blat.target_start ) < 5000 and 
       blat.is_best_alignment = 1 and
       est.library_id = l.library_id and
       estseq.na_sequence_id = est.na_sequence_id and
       so.sequence_ontology_id = estseq.sequence_ontology_id and
       so.term_name = 'EST' and
       blat.target_na_sequence_id = $srcfeature_id
ORDER BY 
       blat.target_start
]]>
    </sql>
  </sqlQuery>
  

  <sqlQuery name="proteinAlignment:BLAT">
     <sql>
<![CDATA[
SELECT blat.blat_protein_alignment_id feature_id, 
       'proteinAlignment' type, 
       'BLAT' source, 
       eaas.source_id as name, 
       blat.score score, 
       blat.query_aa_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'PercentIdentity=' || blat.percent_identity  || '$dlm' ||
       'Defline=' || eaas.description atts 
FROM   
       ApiDBTuning.BlatProtAlignLocation blat, 
       DOTS.externalaasequence eaas
WHERE  
       blat.query_aa_sequence_id = eaas.aa_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       (blat.target_end - blat.target_start ) < 5000 and 
       blat.target_na_sequence_id = $srcfeature_id
ORDER BY 
       blat.target_start
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="alignment:Bacs" includeProjects="ToxoDB,TriTrypDB">
     <sql>
<![CDATA[
select f.feature_id, f.type, f.source, 
       CASE WHEN f.taxon like 'Leishmania%' OR f.taxon like 'Trypanosoma%'
              THEN f.feature_id
            WHEN f.taxon like 'Toxoplasma%'
              THEN f.feature_id  || '[p/q]1c' 
       END name,
f.feature_id name, f.parent_id, f.startm, f.end,
'sequence=' || substr(s.sequence, f.startm, f.end - f.startm + 1) || '$dlm' ||
'sequence_id=' || s.source_id || '$dlm' ||
'ExtDbName=' || f.database_name atts
from dots.nasequence s, (
select bacs.feature_id,
       'alignment' type,       
       'Bacs' source,
        max(bacs.query_na_sequence_id) parent_id,
        min(bacs.target_start) startm,        
        max(bacs.target_end) end,
        max(bacs.target_na_sequence_id) as query_na_sequence_id,
        bacs.name database_name,bacs.taxon as taxon
FROM (
SELECT CASE WHEN tn.name like 'Leishmania%' OR tn.name like 'Trypanosoma%'
              THEN regexp_substr(source_id, '(.*)[^(d_T7\.(1-2)|L)(d_SP6\.1|R)]')
            WHEN tn.name like 'Toxoplasma%'
              THEN regexp_substr(etn.source_id, '(.*)[^(q|p)1c)]')
       END feature_id,tn.name as taxon,
       blat.query_na_sequence_id, blat.target_start, blat.target_end,
       blat.target_na_sequence_id, ed.name 
FROM ApidbTuning.BlatAlignmentLocation blat,
dots.ExternalNASequence etn, Sres.taxonname tn, 
sres.ExternalDatabase ed, sres.externalDatabaseRelease edr
WHERE blat.query_na_sequence_id = etn.na_sequence_id
AND blat.target_na_sequence_id = $srcfeature_id
AND blat.is_best_alignment = 1
AND (blat.target_end - blat.target_start ) < 5000
AND (tn.name like 'Toxoplasma%' OR blat.number_of_spans =1)
AND etn.external_database_release_id = edr.external_database_release_id
AND ed.external_database_id=edr.external_database_id
AND etn.taxon_id = tn.taxon_id
AND tn.name_class = 'scientific name'
AND ed.name in ('Lmajor_sanger_BACEnds_RSRC',
                'Tbrucei_Genbank_BACEnds_RSRC',
                'Tcruzi_BACEnds_RSRC',
                'Lmajor_sanger_PACEnds_RSRC',
                'tgonME49_Sanger_BAC_ends_clonedInsertEnds_RSRC')
) bacs
GROUP BY bacs.feature_id, bacs.name, bacs.taxon
) f
WHERE f.startm <= $rend AND f.end >= $base_start  - 1
and f.query_na_sequence_id = s.na_sequence_id
ORDER BY f.startm
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="alignment:Cosmids" includeProjects="ToxoDB,TriTrypDB">
    <testParamValues project="TriTrypDB">
      <param name="srcfeature_id" value="$$na_feat_id_LmjF24_01_20050601_V5.2$$"/>
      <param name="rend" value="204367"/>
      <param name="base_start" value="203962"/>
    </testParamValues>
     <sql>
<![CDATA[
select f.feature_id, f.type, f.source, f.feature_id name, f.parent_id, f.startm, f.end,
'sequence=' || substr(s.sequence, f.startm, f.end - f.startm + 1) || '$dlm' ||
'alignLength=' || ( f.end - f.startm + 1) || '$dlm' ||
'sequence_id=' || s.source_id atts
from dots.nasequence s, (

SELECT bacs.feature_id, 
       'alignment' type, 
       '$source' source,
       max(bacs.query_na_sequence_id) parent_id, 
       min(bacs.target_start) startm, 
       max(bacs.target_end) end,
       max(bacs.target_na_sequence_id) as query_na_sequence_id
FROM (
SELECT CASE WHEN tn.name like 'Leishmania%' OR tn.name like 'Trypanosoma%'
              THEN regexp_substr(etn.source_id, '(.*)[^(X)(Y)]')
       WHEN (tn.name like 'Toxoplasma%' AND etn.secondary_identifier IS NOT NULL)
              THEN regexp_substr(etn.secondary_identifier, '(.*)[^_forward|_reverse]')
       WHEN tn.name like 'Toxoplasma%'
              THEN regexp_substr(etn.source_id, '(.*)[^T(V|H)]')
       END feature_id,
       blat.query_na_sequence_id, blat.target_start, blat.target_end,
       blat.target_na_sequence_id
FROM ApidbTuning.BlatAlignmentLocation blat, dots.ExternalNASequence etn, 
     sres.EXTERNALDATABASE ed, sres.EXTERNALDATABASERELEASE edr,
     Sres.taxonname tn
WHERE blat.query_na_sequence_id = etn.na_sequence_id 
AND blat.target_na_sequence_id = $srcfeature_id 
AND blat.target_start >= $base_start  -1 
AND blat.target_end <= $rend
AND blat.is_best_alignment = 1
AND (tn.name like 'Toxoplasma%' OR blat.number_of_spans =1)
AND edr.external_database_id = ed.external_database_id
AND edr.external_database_release_id = etn.external_database_release_id
AND etn.taxon_id = tn.taxon_id
AND tn.name_class = 'scientific name'
AND ed.name = $$edName$$
) bacs
GROUP BY bacs.feature_id
) f
where f.query_na_sequence_id = s.na_sequence_id
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="annotation:density">
     <sql>
<![CDATA[
SELECT etn.na_sequence_id feature_id, 
       'annotation' type, 
       'density' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name = "ORF:density"> 
    <description>ORF density. bin size is 500bp.</description> 
    <sql> 
<![CDATA[ 
SELECT etn.na_sequence_id feature_id, 
       'ORF' type, 
       'density' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>
  
<!--
  <sqlQuery name = "ORF300:density"> 
    <description>ORF density. bin size is 500bp.</description> 
    <sql> 
<![CDATA[ 
SELECT etn.na_sequence_id feature_id, 
       'ORF300' type, 
       'density' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name = "ORF600:density"> 
    <description>ORF density. bin size is 500bp.</description> 
    <sql> 
<![CDATA[ 
SELECT etn.na_sequence_id feature_id, 
       'ORF' type, 
       'density' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>

-->

  <sqlQuery name="Centromere:overview"  includeProjects="PlasmoDB,ToxoDB">
    <testParamValues project="PlasmoDB">
       <param name="srcfeature_id" value="$$na_seq_id_Pf3D7_09$$"/>
    </testParamValues>
     <sql>
<![CDATA[
SELECT fl.na_sequence_id feature_id,
       'Centromere' type,
       'overview' source,
       start_min startm,
       end_max end
FROM  ApidbTuning.FeatureLocation fl, sres.sequenceOntology so  
WHERE fl.na_sequence_id = $srcfeature_id
  AND so.sequence_ontology_id = fl.sequence_ontology_id 
  AND so.term_name='centromere'    
]]> 
    </sql> 
  </sqlQuery>
 
  <sqlQuery name="TandemRepeat:TRF">
     <sql>
<![CDATA[
 SELECT
       fl.na_feature_id feature_id,
       'TandemRepeat' type, 
       'TRF' source, 
       tr.name name, 
       '.' score, 
       fl.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=here to work around Feature.pm bug of splitting null atts' atts
FROM 
       dots.NaFeature tr,
       ApidbTuning.FeatureLocation fl
WHERE
       tr.na_feature_id = fl.na_feature_id and
       fl.feature_type = 'TandemRepeatFeature' and
       fl.start_min <= $rend and 
       fl.end_max >= $base_start and 
       fl.na_sequence_id = $srcfeature_id
ORDER BY 
       fl.start_min
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="feature:BindingSite">
     <sql>
<![CDATA[
 SELECT
       fl.na_feature_id feature_id,
       'feature' type, 
       'BindingSite' source, 
       BS.name name, 
       '.' score, 
       fl.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Name=' || BS.name || '$dlm' ||       
       'Sequence=' || substr(s.sequence, fl.start_min, fl.end_max - fl.start_min + 1)  || '$dlm' ||
       'Score=' || to_char(exp(BS.primary_score),'9.99EEEE') as atts
FROM 
       dots.BindingSiteFeature BS,
       ApidbTuning.FeatureLocation fl,
       dots.nasequence s,
       sres.externaldatabase d,
       sres.externaldatabaserelease rel
WHERE
       fl.na_sequence_id = s.na_sequence_id and
       BS.na_feature_id = fl.na_feature_id and
       rel.external_database_release_id = BS.external_database_release_id and
       d.external_database_id  = rel.external_database_id and
       d.name like '%_genomeFeature_Llinas_TransFactorBindingSites%' and
       fl.feature_type = 'BindingSiteFeature' and
       fl.start_min <= $rend and 
       fl.end_max >= $base_start and 
       fl.na_sequence_id = $srcfeature_id
ORDER BY 
       fl.start_min
]]>
    </sql>
  </sqlQuery>

 

 
  <sqlQuery name="repeat_region:Genbank" includeProjects="TrichDB">
    <testParamValues project="TrichDB">
      <param name="srcfeature_id" value="$$na_seq_id_DS123607$$"/>
      <param name="rend" value="1502"/>
      <param name="base_start" value="533"/>
    </testParamValues>
  <sql>
<![CDATA[ 
SELECT gf.na_feature_id feature_id,
       'repeat_region' type, 
       'Genbank' source, 
       gf.source_id name, 
       gf.na_sequence_id parent_id, 
       ga.start_min startm, 
       ga.end_max end, 
       decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=' || ga.product  || '$dlm' ||
       'soTerm=' || ga.so_term_name || '$dlm' ||
       'product=' || replace(ga.product,'''','&#146;') || '$dlm' ||
       'taxon=' || ga.organism || '$dlm' ||
       'isPseudo=' || ga.is_pseudo
         as atts
FROM   dots.GENEFEATURE gf, 
       dots.NALOCATION nal,
       ApidbTuning.GeneAttributes ga 
WHERE  ga.so_term_name = 'repeat_region'
   AND nal.na_feature_id = gf.na_feature_id
   AND ga.start_min <= $rend 
   AND ga.end_max >= $base_start 
   AND gf.source_id = ga.source_id
   AND gf.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>    
  
  <sqlQuery name="alignment:dbEST">
     <sql>
<![CDATA[
 SELECT blat.blat_alignment_id feature_id, 
       'alignment' type, 
       'dbEST' source, 
       est.accession name, 
       blat.score || '' score, 
       blat.query_na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'PercentIdentity=' || blat.percent_identity  || '$dlm' ||
       'Library=' || l.dbest_name  || '$dlm' atts 
FROM   
       ApidbTuning.BlatAlignmentLocation blat, 
       dots.Est est, 
       dots.ExternalNASequence estseq,
       dots.Library l,
       sres.SequenceOntology so
WHERE  
       blat.query_na_sequence_id = est.na_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       (blat.target_end - blat.target_start ) < 5000 and 
       blat.is_best_alignment = 1 and
       est.library_id = l.library_id and
       estseq.na_sequence_id = est.na_sequence_id and
       so.sequence_ontology_id = estseq.sequence_ontology_id and
       so.term_name = 'EST' and
       blat.target_na_sequence_id = $srcfeature_id
ORDER BY 
       blat.target_start
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="alignment:RandomEnds" excludeProjects="PlasmoDB,ToxoDB,CryptoDB,GiardiaDB,TrichDB">
    <testParamValues project="TriTrypDB">
      <param name="srcfeature_id" value="$$na_feat_id_LmjF01_01_20050601_5.2$$"/>
    </testParamValues>
     <sql>
<![CDATA[
select f.feature_id, f.type, f.source, f.name, f.parent_id, f.startm, f.end,
     'sequence=' || substr(s.sequence, f.startm, f.end - f.startm + 1) || '$dlm' ||
     'sequence_id=' || s.source_id  atts
from dots.nasequence s, (
SELECT regexp_substr(etn.source_id, '(.*)[^(x1-4)(y1-4)]') feature_id, 
       'alignment' type,
       'RandomEnds' source,
       regexp_substr(etn.source_id, '(.*)[^(x1-4)(y1-4)]') name, 
       max(blat.query_na_sequence_id) parent_id,
       min(blat.target_start) startm,
       max(blat.target_end) end,
       max(blat.target_na_sequence_id) as query_na_sequence_id
FROM   ApidbTuning.BlatAlignmentLocation blat,
       dots.ExternalNASequence etn
WHERE  blat.query_na_sequence_id = etn.na_sequence_id
  AND  blat.target_na_sequence_id = $srcfeature_id
  AND  blat.is_best_alignment = 1
  AND  (blat.target_end - blat.target_start ) < 5000
  AND  etn.external_database_release_id = blat.query_external_db_release_id
  AND  blat.number_of_spans =1
  AND  blat.query_external_db_release_id in (
  SELECT edr.external_database_release_id
  FROM sres.EXTERNALDATABASE ed, sres.EXTERNALDATABASERELEASE edr
  WHERE ed.external_database_id=edr.external_database_id
  AND ed.name = 'Lmajor_sanger_FV1Ends_RSRC'
  )
GROUP BY regexp_substr(etn.source_id, '(.*)[^(x1-4)(y1-4)]')
) f
WHERE f.startm <= $rend AND f.end >= $base_start - 1
 and f.query_na_sequence_id = s.na_sequence_id
ORDER BY f.startm
]]>
    </sql>
  </sqlQuery>
  
  
  
<!-- 
  <sqlQuery name="clusteralignment:EstCluster">
     <sql>
<![CDATA[
 SELECT blat.blat_alignment_id feature_id, 
       'clusteralignment' type, 
       'EstCluster' source, 
       a.source_id name, 
       blat.score || '' score, 
       blat.target_na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'PercentIdentity=' || blat.percent_identity || '$dlm' ||
       'Count=' || a.number_of_contained_sequences atts 
FROM   
       ApidbTuning.BlatAlignmentLocation blat, 
       dots.Assembly a
WHERE  
       blat.query_na_sequence_id = a.na_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       blat.is_best_alignment = 1 and
       blat.target_na_sequence_id = $srcfeature_id
ORDER BY 
       blat.target_start
]]>
    </sql>
  </sqlQuery>
 --> 
  
  <sqlQuery name="Microsatellite:sts" includeProjects="PlasmoDB">
    <testParamValues project="PlasmoDB">
       <param name="srcfeature_id" value="$$na_seq_id_Pf3D7_06$$"/>
       <param name="base_start" value="469864"/> 
       <param name="rend" value="470011"/> 
    </testParamValues>
     <sql>
<![CDATA[
 SELECT S.na_feature_id as feature_id,
       'Microsatellite' type, 
       'sts' source, 
       s.source_id name, 
       s.na_sequence_id parent_id, 
       l.start_min startm, 
       l.end_max end, 
       decode (l.is_reversed, 0, '+1', 1, '-1', '.') strand,
             'Name=' || s.name  || '$dlm' || 'SequenceId=' || nas.source_id  atts
      FROM   DoTS.STS s, SRes.sequenceontology so,
             ApidbTuning.FeatureLocation l, DOTS.NASequence nas
      WHERE  s.na_sequence_id = $srcfeature_id 
        AND  l.start_min <= $rend
        AND  l.end_max >= $base_start
        AND  s.na_feature_id = l.na_feature_id 
        AND  nas.na_sequence_id = s.na_sequence_id
        AND  s.sequence_ontology_id = so.sequence_ontology_id
        AND so.term_name = 'microsatellite'
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="Haplotype:Block">
     <sql>
<![CDATA[
SELECT  cef.na_feature_id feature_id,
       'Haplotype' type, 
       'Block' source, 
       cef.source_id name, 
       '.' score, 
       cef.na_sequence_id parent_id, 
       nl.start_min startm, 
       nl.end_max end, 
       'Boundary=' || 'Liberal'  || '$dlm' ||'Name=' || cef.name  || '$dlm' || 'SequenceId=' || ens.source_id  || '$dlm' || 'start_max=' || nl.start_max || '$dlm' ||'end_min=' || nl.end_min || '$dlm' || 'start_min=' || nl.start_min || '$dlm' || 'end_max=' || nl.end_max as atts
FROM DoTS.ChromosomeElementFeature cef, Dots.NaLocation nl, DoTS.ExternalNASequence ens
         WHERE  cef.na_sequence_id = $srcfeature_id 
         AND    cef.na_feature_id = nl.na_feature_id 
         AND    ens.na_sequence_id = cef.na_sequence_id
         AND    nl.start_min <= $rend
         AND    nl.end_max >= $base_start
]]>
    </sql>
  </sqlQuery>
 
 
 
  
<!-- NOTE: externalDatabase.name list specified in query, for Crypto AND Plasmo -->
  <sqlQuery name="match:IsolatePopset" excludeProjects="TriTrypDB,GiardiaDB,TrichDB">
    <testParamValues project="ToxoDB">
       <param name="srcfeature_id" value="$$na_seq_id_scf_1107000999162$$"/>
       <param name="base_start" value="893548"/>
       <param name="rend" value="894278"/>
    </testParamValues>
    <testParamValues project="CryptoDB">
       <param name="srcfeature_id" value="$$na_seq_id_scf_23$$"/>
       <param name="base_start" value="445770"/>
       <param name="rend" value="450820"/>
    </testParamValues>
    <sql>
<![CDATA[
SELECT distinct sim.similarity_id feature_id, 
       'match' type, 
       'IsolatePopset' source, 
       extq.source_id name, 
       sim.score,
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) pvalue, 
       extt.na_sequence_id parent_id, 
       sim.min_subject_start startm, 
       sim.max_subject_end end, 
       decode (sim.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||'$dlm'|| 
       'MatchLen=' || sim.total_match_length || '$dlm' ||
       'Note=' || extq.description atts
FROM   
       dots.Similarity sim, 
       dots.ExternalNASequence extt, dots.NASequence extq,
       sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
WHERE  
       extq.external_database_release_id = edr.external_database_release_id and
       ed.external_database_id = edr.external_database_id and
       (   ed.name in ('C. parvum isolate data', 'Toxoplasma isolates From David Sibley','Toxoplasma isolates From Genbank') 
        or ed.name like '%_isolates_genbank_RSRC') and
       sim.query_id = extq.na_sequence_id and 
       sim.subject_id = extt.na_sequence_id and 
       sim.pvalue_mant is not null and
       sim.pvalue_exp is not null and
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) < 1e-20 and 
       sim.min_subject_start >= $base_start and 
       sim.max_subject_end <= $rend 
       AND extt.na_sequence_id = $srcfeature_id 
ORDER BY 
       sim.min_subject_start asc, 
       sim.max_subject_end asc, 
       pvalue asc
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="scaffold:genome" includeProjects="PlasmoDB,ToxoDB,TriTrypDB,GiardiaDB">
     <sql>
<![CDATA[
 SELECT 's.' || piece_na_sequence_id as feature_id, 
     'scaffold' type,
     'genome' source,
      source_id as name,
      offset as startm,
      (offset + length) as end,
      decode(strand_orientation, '+', '+1', '-', '-1', '', '+1', '0') strand,
      'Length=' || length || '$dlm' ||
      'Type=scaffold' || '$dlm' ||
      'Note=' || source_id atts
FROM (
(SELECT ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length as chr_length, sp.strand_orientation,
       0 as offset
 FROM dots.VirtualSequence vs, dots.SequencePiece sp,
     dots.ExternalNaSequence ens
 WHERE vs.na_sequence_id = $srcfeature_id 
  and vs.na_sequence_id = sp.virtual_na_sequence_id
  and ens.na_sequence_id = sp.piece_na_sequence_id
  and sp.sequence_order = 1 
GROUP by ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length, sp.strand_orientation)
UNION
(SELECT ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length as chr_length, sp.strand_orientation,
       sum(predecessors.length) as offset
 FROM dots.VirtualSequence vs, dots.SequencePiece sp,
     dots.ExternalNaSequence ens,
     (select sp2.virtual_na_sequence_id, sp2.sequence_order, ens2.length
      from dots.SequencePiece sp2,
           dots.ExternalNaSequence ens2
      where sp2.piece_na_sequence_id = ens2.na_sequence_id) predecessors
 WHERE vs.na_sequence_id = $srcfeature_id 
  and vs.na_sequence_id = sp.virtual_na_sequence_id
  and ens.na_sequence_id = sp.piece_na_sequence_id
  and vs.na_sequence_id = predecessors.virtual_na_sequence_id(+)
  and sp.sequence_order > predecessors.sequence_order
  and ens.external_database_release_id is not null
GROUP by ens.source_id, sp.piece_na_sequence_id, sp.sequence_order,
       ens.length, vs.length, sp.strand_orientation )
ORDER by offset) 
where offset < $rend and (offset+length) > $base_start
UNION
SELECT 'g.' || $srcfeature_id as feature_id,
       'scaffold' type,
       'genome' source,
       'aGap' name,
       $base_start as startm,
       $rend as end,
       '0' as strand,
       'Type=fgap' as atts
FROM DUAL   
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="gene:AlternateModels">
     <sql>
<![CDATA[
SELECT
       gf.na_feature_id feature_id,
       'gene' type, 
       '$source' source, 
       gf.source_id name, 
       '.' score, 
       gf.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       ed.name||':'||edr.version external_database_name,
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=' || gf.product  || '$dlm' ||
       'soTerm=' || so.term_name || '$dlm' ||
       'product=' || replace(gf.product,'''','&#146;') || '$dlm' ||
       'taxon=' || tn.name || '$dlm' ||
       'SecondaryScore=' || gf.secondary_score || '$dlm' ||
       'score=' || round(gf.score,4) || '$dlm' ||
       'isPseudo=' || gf.is_pseudo || '$dlm' ||
       'ExtDbName=' ||  ed.name || '$dlm' ||
       'Version=' ||  edr.version || '$dlm' ||
       'FeatureType=' || fl.feature_type
         as atts
FROM 
       dots.GeneFeature gf,
       ApidbTuning.FeatureLocation fl, 
       dots.NASequence ns,
       sres.TaxonName tn,
       sres.SequenceOntology so,
       sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.na_sequence_id = ns.na_sequence_id
  AND  fl.feature_type = 'GenePrediction'
  AND  fl.na_feature_id = gf.na_feature_id 
  AND  so.sequence_ontology_id = gf.sequence_ontology_id
  AND  fl.start_min <= $rend 
  AND  fl.end_max >= $base_start 
  AND  tn.taxon_id = ns.taxon_id 
  AND  tn.name_class = 'scientific name' 
  AND  gf.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name = $$extDbName$$ 
ORDER BY 
       fl.start_min
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="gene:JcviPasa">
    <sql>
<![CDATA[ 
SELECT g3.parent_attr feature_id,
       'gene' type,
       'JcviPasa' source,
       g3.parent_attr name,
       '.' score,
       g3.na_sequence_id parent_id,
       min(g3.mapping_start) startm,
       max(g3.mapping_end) end,
       decode (g3.is_reversed, 0, '+1', 1, '-1', '.') strand,
       '' atts 
FROM   apidb.gff3 g3, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
WHERE g3.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND g3.na_sequence_id = $srcfeature_id
  AND g3.mapping_start <= $rend
  AND g3.mapping_end >= $base_start
  AND ed.name = 'TgonME49_JCVI_Reannotation_RSRC'
GROUP BY g3.parent_attr, g3.na_sequence_id, g3.is_reversed
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="gene:OldModels" includeProjects="PlasmoDB,ToxoDB">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'gene' type, 
       '$source' source, 
       enas.source_id  name, 
       blat.score || '' score, 
       etn.na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'soTerm=' || ga.so_term_name || '$dlm' ||
       'product=' ||  oa.value || '$dlm' ||
       'taxon=' || ga.organism atts 
FROM   ApidbTuning.BlatAlignmentLocation blat, 
       dots.ExternalNASequence enas, dots.NASequence etn,
       apidb.OldAnnotation oa, apidbtuning.GeneAttributes ga, apidbtuning.GeneId gi,
       SRes.ExternalDatabase ed, sres.ExternalDatabaseRelease edr 
WHERE  blat.query_na_sequence_id = enas.na_sequence_id
  AND  blat.target_na_sequence_id = etn.na_sequence_id
  AND  blat.is_best_alignment = 1
  AND  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  etn.na_sequence_id = $srcfeature_id
  AND  enas.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name $$oldTranscriptEdName$$
  AND  enas.source_id = oa.source_id
  AND  oa.type='product'
  AND  enas.source_id = gi.id
  AND ga.source_id = gi.gene
UNION
SELECT
       gf.na_feature_id feature_id,
       'gene' type, 
       '$source' source, 
       gf.source_id name, 
       '.' score, 
       gf.na_sequence_id parent_id, 
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'soTerm=' || so.term_name || '$dlm' ||
       'product=' || replace(gf.product,'''','&#146;') || '$dlm' ||
       'taxon=' || tn.name as atts
FROM   dots.GeneFeature gf,
       ApidbTuning.FeatureLocation fl, 
       dots.NASequence ns,
       sres.TaxonName tn,
       sres.SequenceOntology so,
       sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
WHERE  fl.na_sequence_id =$srcfeature_id
  AND  fl.na_sequence_id = ns.na_sequence_id
  AND  fl.feature_type = 'GenePrediction'
  AND  fl.na_feature_id = gf.na_feature_id 
  AND  so.sequence_ontology_id = gf.sequence_ontology_id
  AND  fl.start_min <= $rend 
  AND  fl.end_max >= $base_start 
  AND  tn.taxon_id = ns.taxon_id 
  AND  tn.name_class = 'scientific name' 
  AND  gf.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name $$oldAnnEdName$$ 
  AND is_predicted=1
]]>
      </sql>
  </sqlQuery>


  <sqlQuery name="alignment:sequence" includeProjects="CryptoDB">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'alignment' type, 
       '$source' source, 
       enas.source_id  name, 
       blat.score || '' score, 
       etn.na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       ' ' atts
FROM   ApidbTuning.BlatAlignmentLocation blat, 
       dots.ExternalNASequence enas, dots.NASequence etn,
       SRes.ExternalDatabase ed, sres.ExternalDatabaseRelease edr 
WHERE  blat.query_na_sequence_id = enas.na_sequence_id
  AND  blat.target_na_sequence_id = etn.na_sequence_id
  AND  blat.is_best_alignment = 1
  AND  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  etn.na_sequence_id = $srcfeature_id
  AND  enas.external_database_release_id = edr.external_database_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name $$edName$$
]]>
      </sql>
  </sqlQuery>


  <sqlQuery name="match:syntenySpanMC" includeProjects="TriTrypDB,PlasmoDB,CryptoDB,GiardiaDB,AmoebaDB,MicrosporidiaDB,PiroplasmaDB">
     <sql>
<![CDATA[
SELECT
       syn.synteny_id feature_id,
       'match' type, 
       'syntenySpanMC' source, 
       b.source_id name, 
       '.' score, 
       syn.synteny_id parent_id, 
       CASE WHEN (is_reversed = 1) 
         THEN anch_left.ref_loc - ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1))
         ELSE anch_left.ref_loc - ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
       END startm,
       CASE WHEN (is_reversed = 1) 
         THEN anch_left.ref_loc + ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1))
         ELSE anch_left.ref_loc + ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
       END end, 
       decode(is_reversed, 0, '+1', 1, '-1', '+1') strand,
       'RefStart=' || syn.a_start || '$dlm' ||
       'RefEnd=' || syn.a_end || '$dlm' ||
       'RefContigLength=' || a.length || '$dlm' ||
       'SynStart=' || syn.b_start || '$dlm' ||
       'SynEnd=' || syn.b_end || '$dlm' ||
       'ContigLength=' || b.length || '$dlm' ||
       'Contig=' || b.source_id || '$dlm' ||
       'Chromosome=' || b.chromosome || '$dlm' ||
        (CASE WHEN (b.chromosome is NOT NULL) 
             THEN (SELECT 'ChrColor=' || rcc.value || '$dlm' 
                  FROM apidb.rodentChrColors rcc 
                   WHERE b.chromosome = rcc.chromosome) 
             ELSE ''
             END) || 
       'ExtDBName=' || ed.name || '$dlm' ||
       'Taxon=' || b.organism ||  '$dlm' ||
       'Scale=' || 
       CASE WHEN (is_reversed = 1) 
         THEN (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1)
         ELSE (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1) 
         END atts
FROM 
      apidb.synteny syn,
      apidb.syntenyAnchor anch_left,
      apidb.syntenyAnchor anch_right,
      ApidbTuning.SequenceAttributes a,
      ApidbTuning.SequenceAttributes b,
      sres.externaldatabaserelease edr,
      sres.externaldatabase ed
WHERE edr.external_database_id = ed.external_database_id
  AND syn.external_database_release_id = edr.external_database_release_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start
  AND syn.a_na_sequence_id = $srcfeature_id
  AND a.na_sequence_id = syn.a_na_sequence_id
  AND b.na_sequence_id = syn.b_na_sequence_id
  AND anch_left.synteny_id = syn.synteny_id
  AND anch_left.prev_ref_loc < $base_start
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc) > 1
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="Synteny:syntenySpanOrg" includeProjects="FungiDB">
     <sql>
<![CDATA[
SELECT
       syn.synteny_id feature_id,
       'Synteny' type, 
       '$source' source, 
       b.source_id name, 
       '.' score, 
       syn.synteny_id parent_id, 
       CASE WHEN (is_reversed = 1) 
         THEN anch_left.ref_loc - ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1))
         ELSE anch_left.ref_loc - ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
       END startm,
       CASE WHEN (is_reversed = 1) 
         THEN anch_left.ref_loc + ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1))
         ELSE anch_left.ref_loc + ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
       END end, 
       decode(is_reversed, 0, '+1', 1, '-1', '+1') strand,
       'RefStart=' || syn.a_start || '$dlm' ||
       'RefEnd=' || syn.a_end || '$dlm' ||
       'RefContigLength=' || a.length || '$dlm' ||
       'SynStart=' || syn.b_start || '$dlm' ||
       'SynEnd=' || syn.b_end || '$dlm' ||
       'ContigLength=' || b.length || '$dlm' ||
       'Contig=' || b.source_id || '$dlm' ||
       'Chromosome=' || b.chromosome || '$dlm' ||
        (CASE WHEN (b.chromosome is NOT NULL) 
             THEN (SELECT 'ChrColor=' || rcc.value || '$dlm' 
                  FROM apidb.rodentChrColors rcc 
                   WHERE b.chromosome = rcc.chromosome) 
             ELSE ''
             END) || 
       'ExtDBName=' || ed.name || '$dlm' ||
       'Taxon=' || b.organism ||  '$dlm' ||
       'Scale=' || 
       CASE WHEN (is_reversed = 1) 
         THEN (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1)
         ELSE (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1) 
         END atts
FROM 
      apidb.synteny syn,
      apidb.syntenyAnchor anch_left,
      apidb.syntenyAnchor anch_right,
      apidb.sequenceattributes a,
      apidb.sequenceattributes b,
      sres.externaldatabaserelease edr,
      sres.externaldatabase ed
WHERE edr.external_database_id = ed.external_database_id
  AND syn.external_database_release_id = edr.external_database_release_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start
  AND syn.a_na_sequence_id = $srcfeature_id
  AND a.na_sequence_id = syn.a_na_sequence_id
  AND b.na_sequence_id = syn.b_na_sequence_id
  AND b.organism = $$organism$$
  AND anch_left.synteny_id = syn.synteny_id
  AND anch_left.prev_ref_loc < $base_start
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc) > 1
]]>
    </sql>
  </sqlQuery>
 
 <sqlQuery name="match:syntenySpanMC" includeProjects="ToxoDB">
     <sql>
<![CDATA[
 SELECT
       syn.synteny_id || '_syn' feature_id,
       'match' type, 
       'syntenySpanMC' source, 
       b.source_id name, 
       syn.synteny_id parent_id, 
       CASE WHEN (is_reversed = 1) 
         THEN anch_left.ref_loc - ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1))
         ELSE anch_left.ref_loc - ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
       END startm,
       CASE WHEN (is_reversed = 1) 
         THEN anch_left.ref_loc + ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1))
         ELSE anch_left.ref_loc + ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
       END end, 
       decode(is_reversed, 0, '+1', 1, '-1', '+1') strand,
       'RefStart=' || syn.a_start || '$dlm' ||
       'RefEnd=' || syn.a_end || '$dlm' ||
       'RefContigLength=' || a.length || '$dlm' ||
       'SynStart=' || syn.b_start || '$dlm' ||
       'SynEnd=' || syn.b_end || '$dlm' ||
       'ContigLength=' || b.length || '$dlm' ||
       'Contig=' || b.source_id || '$dlm' ||
       --'Chromosome=' || b.chromosome || '$dlm' ||
       'ChrColor=' || '#FF00FF' || '$dlm' ||
       'ExtDBName=' || ed.name || '$dlm' ||
       'Type=scaffold' || '$dlm' ||
       'Taxon=' || tn.name ||  '$dlm' ||
       'Scale=' || 
       CASE WHEN (is_reversed = 1) 
         THEN (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1)
         ELSE (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)
         END atts
FROM 
      apidb.synteny syn,
      apidb.syntenyAnchor anch_left,
      apidb.syntenyAnchor anch_right,
      dots.nasequence a,
      dots.nasequence b,
      sres.externaldatabaserelease edr,
      sres.externaldatabase ed, 
      Sres.TaxonName tn
WHERE edr.external_database_id = ed.external_database_id
  AND syn.external_database_release_id = edr.external_database_release_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start
  AND syn.a_na_sequence_id = $srcfeature_id
  AND a.na_sequence_id = syn.a_na_sequence_id
  AND b.na_sequence_id = syn.b_na_sequence_id
  AND anch_left.synteny_id = syn.synteny_id
  AND anch_left.prev_ref_loc < $base_start
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND b.taxon_id = tn.taxon_id
  AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc + 1) > 0
  AND abs(anch_left.syntenic_loc - anch_right.syntenic_loc + 1) > 0
UNION
SELECT
       syn.synteny_id || '_gap' feature_id,
       'match' type, 
       'syntenySpanMC' source, 
       b.source_id name, 
       syn.synteny_id parent_id, 
       CASE WHEN (is_reversed = 1) 
         THEN anch_left.ref_loc - ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1))
         ELSE anch_left.ref_loc - ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
       END startm,
       CASE WHEN (is_reversed = 1) 
         THEN anch_left.ref_loc + ((anch_left.syntenic_loc - syn.b_start) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc + 1))
         ELSE anch_left.ref_loc + ((syn.b_end - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
       END end, 
       '0' strand,
       'Type=fgap' || '$dlm' ||
       'Taxon=' || tn.name atts
FROM 
      apidb.synteny syn,
      apidb.syntenyAnchor anch_left,
      apidb.syntenyAnchor anch_right,
      dots.nasequence a,
      dots.nasequence b,
      sres.externaldatabaserelease edr,
      sres.externaldatabase ed, 
      Sres.TaxonName tn
WHERE edr.external_database_id = ed.external_database_id
  AND syn.external_database_release_id = edr.external_database_release_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start
  AND syn.a_na_sequence_id = $srcfeature_id
  AND a.na_sequence_id = syn.a_na_sequence_id
  AND b.na_sequence_id = syn.b_na_sequence_id
  AND anch_left.synteny_id = syn.synteny_id
  AND anch_left.prev_ref_loc < $base_start
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND b.taxon_id = tn.taxon_id
  AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc) > 1
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="SNP:Alignment"  includeProjects="ToxoDB">
     <sql>
<![CDATA[
 SELECT  /*+use_nl(sa snp)*/
       sa.na_feature_id          as feature_id,
       'SNP'                      as type, 
       'Alignment'                as source, 
       sa.source_id              as name, 
       '.'                        as score, 
       sa.seq_source_id           as parent_id, 
       sa.start_min               as startm,
       sa.start_min               as end,
       decode(sa.gene_strand, 'forward', '+1', 'reverse', '-1', '.') as strand,
       'RefNA='   || sa.reference_na || '$dlm' ||
       'base_start='   || '$base_start' || '$dlm' ||
       'rend='   || '$rend' || '$dlm' ||
       'NonSyn='   || sa.has_nonsynonymous_allele || '$dlm'||
       'IsCoding=' || sa.is_coding || '$dlm' ||
       'Gene=' || sa.gene_source_id || '$dlm' ||
       'params=' || sa.position_in_CDS || '&' ||
       sa.position_in_protein || '&' ||
       sa.reference_strain || '&' ||
       sa.reference_aa || '&' ||
       sa.gene_strand || '&' ||
       sa.reference_na || '&' ||
       sa.source_id 
        as atts
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SnpAttributes sa
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.start_min <= $rend
  AND  fl.start_min >= $base_start
  AND  fl.na_feature_id = sa.na_feature_id
  AND  sa.dataset =  'tgonME49_SNP_Amit_nucmer_gff_RSRC'
]]>
    </sql>
  </sqlQuery>
  
    <sqlQuery name="htsSNP:Alignment"  includeProjects="ToxoDB,AmoebaDB,TriTrypDB,CryptoDB,PlasmoDB">
     <sql>
<![CDATA[
 SELECT  /*+use_nl(sa snp)*/
       sa.na_feature_id          as feature_id,
       'htsSNP'                      as type, 
       'Alignment'                as source, 
       sa.source_id              as name, 
       '.'                        as score, 
       sa.seq_source_id           as parent_id, 
       sa.start_min               as startm,
       sa.start_min               as end,
       decode(sa.gene_strand, 'forward', '+1', 'reverse', '-1', '.') as strand,
       'RefNA='   || sa.reference_na || '$dlm' ||
       'base_start='   || '$base_start' || '$dlm' ||
       'rend='   || '$rend' || '$dlm' ||
       'NonSyn='   || sa.has_nonsynonymous_allele || '$dlm'||
       'IsCoding=' || sa.is_coding || '$dlm' ||
       'Gene=' || sa.gene_source_id || '$dlm' ||
       'position_in_CDS=' || sa.position_in_CDS || '$dlm' ||
       'position_in_protein=' || sa.position_in_protein || '$dlm' ||
       'reference_strain=' || sa.reference_strain || '$dlm' ||
       'reference_aa=' || sa.reference_aa || '$dlm' ||
       'gene_strand=' || sa.gene_strand || '$dlm' ||
       'reference_na=' || sa.reference_na || '$dlm' ||
       'source_id=' || sa.source_id as atts
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SnpAttributes sa
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.start_min <= $rend
  AND  fl.start_min >= $base_start
  AND  fl.na_feature_id = sa.na_feature_id
  AND  sa.dataset = 'InsertSnps.pm NGS SNPs INTERNAL'
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="SNP:density"  includeProjects="ToxoDB">
     <sql>
<![CDATA[
 SELECT etn.na_sequence_id feature_id, 
       'SNP' type, 
       'density' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="ChIP_peaks:peaks"  includeProjects="PlasmoDB,ToxoDB">
     <sql>
<![CDATA[
 SELECT ee.na_feature_id   as feature_id,
       'ChIP_peaks'         as type,
       '$source'  as source,
       ee.feature_source_id        as name,
       ee.score      as score,
       ee.na_sequence_id   as parent_id,
       ee.start_min         as startm,
       ee.end_max           as end,
      'Treatment=' || cpp.treatment ||  '$dlm' || 
      'Analysis=' || a.name ||  '$dlm' ||
      'Genotype=' || cpp.genotype ||'$dlm' || 
      'Antibody=' || cpp.antibody || '$dlm' || 
      'Strain=' || cpp.strain || '$dlm' || 
      'Rep=' || cpp.replicate as atts 
FROM   rad.protocol p,rad.analysis a,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  ee.analysis_id =   cpp.analysis_id
AND    cpp.protocol_id =  p.protocol_id
AND    cpp.analysis_id = a.analysis_id
AND    p.name = $$protocol$$
AND    cpp.experiment_name = $$exp$$
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    cpp.protocol_type = 'called_peaks'
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="GeneticMarkers:Sibley"  includeProjects="ToxoDB">
    <testParamValues project="ToxoDB">
       <param name="srcfeature_id" value="$$na_seq_id_X$$"/>
       <param name="rend" value="6929962"/>
       <param name="base_start" value="6766705"/>
    </testParamValues>
     <sql>
<![CDATA[
 SELECT 
       sa.na_feature_id           as feature_id,
       'GeneticMarkers'           as type, 
       'Sibley'                   as source, 
       sa.source_id               as name, 
       '.'                        as score, 
       sa.seq_source_id           as parent_id, 
       sa.start_min               as startm, 
       sa.start_min               as end, 
       decode(sa.gene_strand, 'forward', '+1', 'reverse', '-1', '.') as strand,
       'RefNA='   || sa.reference_na || '$dlm' ||
       'base_start='   || '$base_start' || '$dlm' ||
       'rend='   || '$rend' || '$dlm' ||
       'NonSyn='   || sa.has_nonsynonymous_allele || '$dlm'||
       'IsCoding=' || sa.is_coding || '$dlm' ||
          'Gene=' || sa.gene_source_id || '$dlm' ||
       'PositionInCDS=' || sa.position_in_CDS || '$dlm' ||
       'PositionInProtein=' || sa.position_in_protein || '$dlm' ||
       'RefStrain=' || sa.reference_strain || '$dlm' ||
       'RefAA='   || sa.reference_aa || '$dlm' ||
       sa.gene_strand || '$dlm' ||
       'SourceID='   ||  sa.source_id 
        as atts
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SnpAttributes sa
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.start_min <= $rend
  AND  fl.start_min >= $base_start
  AND  fl.na_feature_id = sa.na_feature_id
  AND  sa.dataset = 'tgonME49_SNP_Sibley_Tg10x_31_gff_RSRC'
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="GeneticMarkers:overview"  includeProjects="ToxoDB">
     <sql>
<![CDATA[
 SELECT
       sv.na_feature_id as feature_id,
       'GeneticMarkers' type, 
       'overview' source, 
       SUBSTR (sv.source_id, 14) as name,
       '.' score, 
       l.sequence_source_id as parent_id, 
       l.start_min as startm, 
       l.end_max as end, 
       decode(l.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=GeneticMarkers' atts
FROM   dots.seqVariation sv, ApidbTuning.FeatureLocation l,
       sres.EXTERNALDATABASERELEASE edr, sres.EXTERNALDATABASE ed
WHERE  sv.external_database_release_id = edr.external_database_release_id and
       edr.external_database_id = ed.external_database_id and
       ed.name = 'tgonME49_SNP_Sibley_Tg10x_31_gff_RSRC'
 AND   l.na_sequence_id = $srcfeature_id
 AND  sv.na_feature_id=l.na_feature_id
]]>
    </sql>
  </sqlQuery>
  

 <sqlQuery name="CGH:CNV">
     <sql>
       <![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'CGH'              as type,
       '$source'          as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE  e.na_sequence_id = $srcfeature_id
       ]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="CGHBlock:CNV">
     <sql>
<![CDATA[
SELECT   feature_id,
        '$source' as source, 
         parent_id as name,
         parent_id as parent_id,
        'CGHBlock' as type,
         startm,
         end,
        'info=' || apidb.tab_to_string(set(cast(COLLECT(attributes order by attributes) AS apidb.varchartab)), '|') || '$dlm' || 'probes=' || probes as atts
FROM    (SELECT   mapping_start as feature_id,
                           NA_SEQUENCE_ID as parent_id,
                           mapping_start as startm,
                           mapping_end as end,
                           SCORE as score,
                           decode (is_reversed, 0, '+1', 1, '-1', '.') as strand,
                           replace(substr(to_char(attr),0, (REGEXP_INSTR(to_char(attr), ';')-1)) , 'probes=') as probes,
                           'strain:' ||  replace(substr(to_char(attr), REGEXP_INSTR(to_char(attr), 'strain=')), 'strain=') || ',score:' || score as attributes
                   FROM    Apidb.GFF3
                   WHERE   MAPPING_START <= $rend 
                   AND     MAPPING_END >= $base_start 
                   AND     na_sequence_id = $srcfeature_id
                   )
GROUP BY feature_id, parent_id, startm,end,probes 
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:TBP_Promastigotes" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'TBP_Promastigotes'              as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>
 
  <sqlQuery name="ChIP:SNAP50_Promastigotes" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'SNAP50_Promastigotes' as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="ChIP:AcetylH3_Promastigotes" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'AcetylH3_Promastigotes' as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:AcetylH3_Log_vs_Stationary" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'AcetylH3_Log_vs_Stationary' as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:TBP_Log_vs_Stationary" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'TBP_Log_vs_Stationary' as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>

 
  <sqlQuery name="ChIP:ChIPchipSub_Strain" includeProjects="ToxoDB">
     <sql>
<![CDATA[
 SELECT distinct p.name || '_' || cpp.strain   as feature_id,
       'ChIP'             as type,
       '$source'          as source,
       '$srcfeature_id'   as name,
       '$srcfeature_id'   as parent_id,
       $base_start        as startm,
       $rend              as end,
       'Strain='     || cpp.strain  as atts
FROM   rad.analysis a,
       rad.protocol p,
       ApidbTuning.ChIPProtocolParams cpp 
WHERE  a.analysis_id = cpp.analysis_id
  AND  a.protocol_id = p.protocol_id
  AND  cpp.experiment_name = $$exp$$
  AND  p.name = $$protocol$$
  AND  cpp.protocol_type = 'raw'
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="ChIP:ChIPchipSub_Antibody" includeProjects="PlasmoDB,ToxoDB">
     <sql>
<![CDATA[
 SELECT distinct p.name || '_' || cpp.antibody   as feature_id,
       'ChIP'             as type,
       '$source'          as source,
       '$srcfeature_id'   as name,
       '$srcfeature_id'   as parent_id,
       $base_start        as startm,
       $rend              as end,
       'Antibody='     || cpp.antibody  as atts
FROM   rad.analysis a,
       rad.protocol p,
       ApidbTuning.ChIPProtocolParams cpp 
WHERE  a.analysis_id = cpp.analysis_id
  AND  a.protocol_id = p.protocol_id
  AND  cpp.experiment_name = $$exp$$
  AND  p.name = $$protocol$$
  AND  cpp.protocol_type = 'raw'
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:Schizont_H3K4me3_H3K9ac" includeProjects="PlasmoDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type, 
       'Schizont_H3K4me3_H3K9ac'         as source, 
       e.source_id        as name, 
       e.source_id        as parent_id, 
       $base_start        as startm, 
       $rend              as end
FROM   DoTS.Nasequence e
WHERE  
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:Schizont_H3_cDNA" includeProjects="PlasmoDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'Schizont_H3_cDNA'         as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>



  <sqlQuery name="ChIP:Ring_H3K4me3_H3K9ac" includeProjects="PlasmoDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'Ring_H3K4me3_H3K9ac'             as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>



  <sqlQuery name="ChIP:Ring_H3_cDNA" includeProjects="PlasmoDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'Ring_H3_cDNA'             as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:Mixed_H3K4me3_H3K9ac" includeProjects="PlasmoDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'Mixed_H3K4me3_H3K9ac'        as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:Mixed_H3K9me3_H3_cDNA" includeProjects="PlasmoDB">
     <sql>
<![CDATA[
 SELECT e.na_sequence_id  as feature_id,
       'ChIP'             as type,
       'Mixed_H3K9me3_H3_cDNA'    as source,
       e.source_id        as name,
       e.source_id        as parent_id,
       $base_start        as startm,
       $rend              as end
FROM   DoTS.Nasequence e
WHERE
       e.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="ChIP:NucleosomeGB2" includeProjects="PlasmoDB">
     <sql>
<![CDATA[
 SELECT name            as feature_id,
       'ChIP'           as type,
       '$source'        as source,
       $srcfeature_id   as name,
       $srcfeature_id   as parent_id,
       $base_start      as startm,
       $rend            as end,
       'name=' || name  as atts
FROM   rad.analysis 
WHERE  name in ($$analysis$$)
]]>
    </sql>
  </sqlQuery>

  
  <sqlQuery name="AffymetrixProbes:Probes"  includeProjects="ToxoDB">
    <sql>
<![CDATA[
 SELECT 
       f.na_feature_id        as feature_id,
       'AffymetrixProbes'     as type, 
       '$source       '       as source, 
       f.source_id            as name, 
       '.'                    as score, 
       f.source_id            as parent_id, 
       l.start_min            as startm, 
       l.end_max              as end, 
       decode(l.is_reversed, 0, '+1', 1, '-1', '.') as strand,
        '' as atts
FROM   dots.ArrayElementFeature f,
       dots.SequencePiece s,
       ApidbTuning.FeatureLocation l,
       sres.ExternalDatabase ed,
       sres.ExternalDatabaseRelease edr  
WHERE  ed.name = $$edname$$
  AND  edr.external_database_id = ed.external_database_id
  AND  f.external_database_release_id = edr.external_database_release_id
  AND  s.virtual_na_sequence_id = $srcfeature_id
  AND  f.na_sequence_id = s.piece_na_sequence_id
  AND  l.na_sequence_id = s.virtual_na_sequence_id 
  AND  l.na_feature_id = f.na_feature_id
  AND  l.start_min <= $rend
  AND  l.end_max >= $base_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="AffymetrixProbes:TBLASTNTranscriptDiscovery"  includeProjects="ToxoDB">
    <testParamValues project="ToxoDB">
       <param name="srcfeature_id" value="$$na_seq_id_X$$"/>
       <param name="rend" value="7279231"/>
       <param name="base_start" value="5214207"/>
    </testParamValues>
     <sql>
<![CDATA[
 SELECT 
       f.na_feature_id            as feature_id,
       'AffymetrixProbes'         as type, 
       'TBLASTNTranscriptDiscovery'   as source, 
       f.source_id                as name, 
       '.'                        as score, 
       f.source_id                as parent_id, 
       l.start_min                as startm, 
       l.end_max                  as end, 
       decode(l.is_reversed, 0, '+1', 1, '-1', '.') as strand
FROM   dots.ArrayElementFeature f,
       dots.SequencePiece s,
       ApidbTuning.FeatureLocation l,
       sres.ExternalDatabase ed,
       sres.ExternalDatabaseRelease edr  
WHERE  ed.name = 'Affymetrix Probes from Amit - TBLASTN-TranscriptDiscovery'
  AND  edr.external_database_id = ed.external_database_id
  AND  f.external_database_release_id = edr.external_database_release_id
  AND  s.virtual_na_sequence_id = $srcfeature_id
  AND  f.na_sequence_id = s.piece_na_sequence_id
  AND  l.na_sequence_id = s.virtual_na_sequence_id 
  AND  l.na_feature_id = f.na_feature_id
  AND  l.start_min <= $rend
  AND  l.end_max >= $base_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="AffymetrixProbes:ESTTranscriptDiscovery"  includeProjects="ToxoDB">
     <sql>
<![CDATA[
 SELECT 
       f.na_feature_id            as feature_id,
       'AffymetrixProbes'         as type, 
       'ESTTranscriptDiscovery'   as source, 
       f.source_id                as name, 
       '.'                        as score, 
       f.source_id                as parent_id, 
       l.start_min                as startm, 
       l.end_max                  as end, 
       decode(l.is_reversed, 0, '+1', 1, '-1', '.') as strand
FROM   dots.ArrayElementFeature f,
       dots.SequencePiece s,
       ApidbTuning.FeatureLocation l,
       sres.ExternalDatabase ed,
       sres.ExternalDatabaseRelease edr  
WHERE  ed.name = 'Affymetrix Probes from Amit - EST-TranscriptDiscovery'
  AND  edr.external_database_id = ed.external_database_id
  AND  f.external_database_release_id = edr.external_database_release_id
  AND  s.virtual_na_sequence_id = $srcfeature_id
  AND  f.na_sequence_id = s.piece_na_sequence_id
  AND  l.na_sequence_id = s.virtual_na_sequence_id 
  AND  l.na_feature_id = f.na_feature_id
  AND  l.start_min <= $rend
  AND  l.end_max >= $base_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="AffymetrixProbes:BLASTXTranscriptDiscovery"  includeProjects="ToxoDB">
    <testParamValues project="ToxoDB">
       <param name="srcfeature_id" value="$$na_seq_id_X$$"/>
       <param name="rend" value="7279231"/>
       <param name="base_start" value="5214207"/>
    </testParamValues>
     <sql>
<![CDATA[
 SELECT 
       f.na_feature_id            as feature_id,
       'AffymetrixProbes'         as type, 
       'BLASTXTranscriptDiscovery'   as source, 
       f.source_id                as name, 
       '.'                        as score, 
       f.source_id                as parent_id, 
       l.start_min                as startm, 
       l.end_max                  as end, 
       decode(l.is_reversed, 0, '+1', 1, '-1', '.') as strand
FROM   dots.ArrayElementFeature f,
       dots.SequencePiece s,
       ApidbTuning.FeatureLocation l,
       sres.ExternalDatabase ed,
       sres.ExternalDatabaseRelease edr  
WHERE  ed.name = 'Affymetrix Probes from Amit - BLASTX-TranscriptDiscovery'
  AND  edr.external_database_id = ed.external_database_id
  AND  f.external_database_release_id = edr.external_database_release_id
  AND  s.virtual_na_sequence_id = $srcfeature_id
  AND  f.na_sequence_id = s.piece_na_sequence_id
  AND  l.na_sequence_id = s.virtual_na_sequence_id 
  AND  l.na_feature_id = f.na_feature_id
  AND  l.start_min <= $rend
  AND  l.end_max >= $base_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="AffymetrixProbes:NuclearNonCoding"  includeProjects="ToxoDB">
    <testParamValues project="ToxoDB">
       <param name="srcfeature_id" value="$$na_seq_id_IX$$"/>
       <param name="rend" value="5141061"/>
       <param name="base_start" value="5139825"/>
    </testParamValues>
     <sql>
<![CDATA[
 SELECT 
       f.na_feature_id            as feature_id,
       'AffymetrixProbes'         as type, 
       'NuclearNonCoding'          as source, 
       f.source_id                as name, 
       '.'                        as score, 
       f.source_id                as parent_id, 
       l.start_min                as startm, 
       l.end_max                  as end, 
       decode(l.is_reversed, 0, '+1', 1, '-1', '.') as strand,
        '' as atts
FROM   dots.ArrayElementFeature f,
       dots.SequencePiece s,
       ApidbTuning.FeatureLocation l,
       sres.ExternalDatabase ed,
       sres.ExternalDatabaseRelease edr  
WHERE  ed.name = 'Affymetrix Probes from Amit - Expression-NuclearNonCoding'
  AND  edr.external_database_id = ed.external_database_id
  AND  f.external_database_release_id = edr.external_database_release_id
  AND  s.virtual_na_sequence_id = $srcfeature_id
  AND  f.na_sequence_id = s.piece_na_sequence_id
  AND  l.na_sequence_id = s.virtual_na_sequence_id 
  AND  l.na_feature_id = f.na_feature_id
  AND  l.start_min <= $rend
  AND  l.end_max >= $base_start
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="SNP:Population"  includeProjects="PlasmoDB,ToxoDB">
     <sql>
<![CDATA[
 SELECT 
       sa.na_feature_id          as feature_id,
       'SNP'                     as type, 
       '$source'                 as source, 
       sa.source_id              as name, 
       sa.seq_source_id          as parent_id, 
       sa.start_min              as startm, 
       sa.start_min              as end, 
       decode(sa.gene_strand, 'forward', '+1', 'reverse', '-1', '.') as strand,
       'base_start='   || '$base_start' || '$dlm' ||
       'rend='   || '$rend' || '$dlm' ||
       'NonSyn='   || sa.has_nonsynonymous_allele || '$dlm'||
       'IsCoding=' || sa.is_coding || '$dlm' ||
       'Gene=' || sa.gene_source_id || '$dlm' ||
       'position_in_CDS=' || sa.position_in_CDS || '$dlm' ||
       'position_in_protein=' || sa.position_in_protein || '$dlm' ||
       'reference_strain=' || sa.reference_strain || '$dlm' ||
       'reference_aa=' || sa.reference_aa || '$dlm' ||
       'gene_strand=' || sa.gene_strand || '$dlm' ||
       'reference_na=' || sa.reference_na || '$dlm' ||
       'source_id=' || sa.source_id as atts
FROM   ApidbTuning.SnpAttributes sa
WHERE  sa.dataset = $$edname$$
  AND  sa.na_sequence_id = $srcfeature_id
  AND  sa.start_min <= $rend
  AND  sa.start_min >= $base_start
]]>
    </sql>
  </sqlQuery>
 
  <sqlQuery name="SNP:Genotyping"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT 
       sa.na_feature_id          as feature_id,
       'SNP'                     as type, 
       '$source'                 as source, 
       sa.source_id              as name, 
       sa.seq_source_id          as parent_id, 
       sa.start_min              as startm, 
       sa.start_min              as end, 
       decode(sa.gene_strand, 'forward', '+1', 'reverse', '-1', '.') as strand,
       'base_start='   || '$base_start' || '$dlm' ||
       'rend='   || '$rend' || '$dlm' ||
       'IsoDbName=' || iso_ext_db_name || '$dlm' ||
       'MinorAllele=' || swi.minor_allele || '$dlm' ||
       'MajorAllele=' || swi.major_allele || '$dlm' ||
       'MinorAlleleFreq=' || swi.minor_allele_frequency || '$dlm' ||
       'NumIsolates=' || swi.number_isolates as atts
FROM   ApidbTuning.SnpsWithIsolates swi, ApidbTuning.SnpAttributes sa
WHERE  swi.snp_source_id = sa.source_id
  AND  sa.na_sequence_id = $srcfeature_id
  AND  sa.start_min <= $rend
  AND  sa.start_min >= $base_start
  AND  sa.dataset = $$edname$$
]]>
    </sql>
  </sqlQuery> 

  <sqlQuery name="SNP:Diversity">
     <sql>
<![CDATA[
SELECT etn.na_sequence_id feature_id, 
       'SNP' type, 
       '$source' source 
FROM   dots.NASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>


  
  
  <sqlQuery name="match:BergmanVaidyaOligos"  includeProjects="PlasmoDB">
    <testParamValues project="PlasmoDB">
       <param name="srcfeature_id" value="$$na_seq_id_AABL01000313$$"/>
       <param name="rend" value="600"/>
       <param name="base_start" value="663"/>
    </testParamValues> 
     <sql>
<![CDATA[
 SELECT
       sim.similarity_id feature_id,
       'match' type,
       'BergmanVaidyaOligos' source,
       qry.source_id name,
       sim.score score,
       sim.query_id    parent_id,
       sim.min_subject_start startm,
       sim.max_subject_end   end,
       decode(sim.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Note=' || subj.description || '$dlm' ||
       'Expect=' || sim.pvalue_mant || 'e' || sim.pvalue_exp || '$dlm' ||
       'PercentIdentity=' || sim.number_identical / sim.total_match_length || '$dlm' ||
       'PercentPositive=' || sim.number_positive / sim.total_match_length atts
 FROM 
       dots.similarity sim,
       core.tableinfo qti,
       core.tableinfo sti,
       dots.externalnasequence subj,
       dots.externalnasequence qry,
       sres.externaldatabase ed1,
       sres.externaldatabase ed2,
       sres.externaldatabaserelease edr1,
       sres.externaldatabaserelease edr2
WHERE 
       sim.min_subject_start <= $rend and 
       sim.max_subject_end >= $base_start and
       sim.subject_id = $srcfeature_id and
       qti.table_id = sim.query_table_id and
       qti.name = 'ExternalNASequence' and
       sti.table_id = sim.subject_table_id and
       sti.name = 'ExternalNASequence' and
       qry.na_sequence_id = sim.query_id and
       subj.na_sequence_id = sim.subject_id and
       subj.external_database_release_id = edr1.external_database_release_id and
       qry.external_database_release_id = edr2.external_database_release_id and
       edr1.external_database_id = ed1.external_database_id and
       edr2.external_database_id = ed2.external_database_id and
       ed1.name = 'Pyoelii_Contigs_RSRC' and
       ed2.name = 'Pyoelii_Vaidya_Bergman_oligos_RSRC'
ORDER BY 
       sim.min_query_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="mapp:promoters"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT $srcfeature_id || '_-1'  as feature_id,
  'mapp'  as type, 
  'promoters'     as source,
  $base_start  as startm,
  $rend        as end,
  -1 as strand,
  '' as atts
from dual
UNION
SELECT $srcfeature_id || '_1'  as feature_id,
  'mapp'  as type, 
  'promoters'     as source,
  $base_start  as startm,
  $rend        as end,
  1 as strand,
  '' as atts
from dual
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="SNP:Widmer"  includeProjects="CryptoDB">
    <testParamValues project="CryptoDB">
       <param name="srcfeature_id" value="$$na_seq_id_CM000431$$"/>
       <param name="base_start" value="150000"/>
       <param name="rend" value="152000"/>
    </testParamValues>
     <sql>
<![CDATA[
 SELECT 
       sa.na_feature_id         as feature_id,
       'SNP'                    as type, 
       'Widmer'                 as source, 
       sa.source_id             as name, 
       sa.seq_source_id         as parent_id, 
       sa.start_min             as startm, 
       sa.start_min             as end, 
       decode(sa.gene_strand, 'forward', '+1', 'reverse', '-1', '.') as strand,
       'RefNA='   || sa.reference_na || '$dlm' ||
       'base_start='   || '$base_start' || '$dlm' ||
       'rend='   || '$rend' || '$dlm' ||
       'NonSyn='   || sa.has_nonsynonymous_allele || '$dlm'||
       'IsCoding=' || sa.is_coding || '$dlm' ||
       'Gene=' || sa.gene_source_id || '$dlm' ||
       'params=' || sa.position_in_CDS || '&' ||
       sa.position_in_protein || '&' ||
       sa.reference_strain || '&' ||
       sa.reference_aa || '&' ||
       sa.gene_strand || '&' ||
       sa.reference_na || '&' ||
       sa.source_id
       as atts
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SnpAttributes sa
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.start_min <= $rend
  AND  fl.start_min >= $base_start
  AND  fl.na_feature_id = sa.na_feature_id
]]>
    </sql>
  </sqlQuery>

<!-- RNA seq queries. Need one / track as too much data to use filters -->

  <sqlQuery name="rnaseq:gcpfwt"  includeProjects="TriTrypDB">
     <sql>
       <![CDATA[
        SELECT 'gcpfwt_id' as feature_id,
               'rnaseq' type,
               'gcpfwt' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:gcbfall"  includeProjects="TriTrypDB">
     <sql>
       <![CDATA[
        SELECT 'gcbfall_id' as feature_id,
               'rnaseq' type,
               'gcbfall' source,
                $base_start as startm,
                $rend       as end
        FROM   dual
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:cn_three_samples"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
        SELECT 'cn_three_sample' as feature_id,
               'rnaseq' type,
               sample as name,
               'cn_three_samples' source,
                $base_start as startm,
                $rend       as end
        FROM   apidb.rnaseq_coverage rc
        WHERE   rc.na_sequence_id = $srcfeature_id
         AND rc.sample in ('24h','8h','40h')
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1
         GROUP BY rc.sample
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:cn_four_samples"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
        SELECT 'cn_four_sample' as feature_id,
               'rnaseq' type,
               sample as name,
               'cn_four_samples' source,
                $base_start as startm,
                $rend       as end 
        FROM   apidb.rnaseq_coverage rc
        WHERE   rc.na_sequence_id = $srcfeature_id
         AND rc.sample in ('0h','16h','32h','48h')
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1
         GROUP BY rc.sample
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:cn_pf0h_lin"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
        SELECT 'rnaseq_0h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf0h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:cn_pf8h_lin"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
        SELECT 'rnaseq_8h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf8h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:cn_pf16h_lin"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
        SELECT 'rnaseq_16h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf16h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:cn_pf24h_lin"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
        SELECT 'rnaseq_24h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf24h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:cn_pf32h_lin"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
        SELECT 'rnaseq_32h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf32h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:cn_pf40h_lin"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
        SELECT 'rnaseq_40h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf40h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="rnaseq:cn_pf48h_lin"  includeProjects="PlasmoDB">
     <sql>
       <![CDATA[
        SELECT 'rnaseq_48h_lin' as feature_id,
               'rnaseq' type,
               'cn_pf48h_lin' source,
                $base_start as startm,
                $rend       as end 
        FROM   dual
       ]]>
    </sql>
  </sqlQuery>

</module>

<!--                       Feature.pm                         -->
<!-- Description: All of the following queries are used by    -->
<!-- sub_SeqFeatures() in Feature.pm.                         -->
<!-- Names are in a format - type:source:subfeatures,         -->
<!-- e.g.  gene:Genbank:subfeatures                           -->
<!-- They should be corespondent with the features types      -->
<!-- implemented in feature() subroutine in Segment.pm        -->

<module name="Feature.pm">


    <sqlQuery name="alignment:RandomEnds:bulksubfeatures">
      <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id, 
       'random_end' type,
       'RandomEnds' source,
       etn.source_id name, 
       regexp_substr(etn.source_id, '(.*)[^(x1-4)(y1-4)]') parent_id, 
       blat.score, 
       blat.target_start startm,
       blat.target_end end,
       'pct=' || blat.percent_identity  atts
FROM   ApidbTuning.BlatAlignmentLocation blat,
       dots.ExternalNASequence etn
WHERE  blat.query_na_sequence_id = etn.na_sequence_id
  AND  blat.target_na_sequence_id = $srcfeature_id
  AND  blat.target_start <= $rend 
  AND  blat.target_end >= $base_start - 1
  AND  blat.is_best_alignment = 1
  AND  (blat.target_end - blat.target_start ) < 5000
  AND  etn.external_database_release_id = blat.query_external_db_release_id
  AND  blat.number_of_spans =1
  AND  blat.query_external_db_release_id in (
       SELECT edr.external_database_release_id
       FROM   sres.EXTERNALDATABASE ed, sres.EXTERNALDATABASERELEASE edr
       WHERE  ed.external_database_id=edr.external_database_id
         AND  ed.name = 'Lmajor_sanger_FV1Ends_RSRC'
  )
]]>
      </sql>
    </sqlQuery>



  <sqlQuery name="gene:annotation:bulksubfeatures">
     <sql>
<![CDATA[
select * from (
SELECT 
       exon_loc.na_feature_id feature_id, 
       'CDS' type, 
       'annotation' source, 
       exon_loc.na_feature_id name,
       exon_loc.parent_id parent_id,
       CASE WHEN exon_loc.is_reversed = 0 THEN
       exon_loc.coding_start ELSE exon_loc.coding_end END as startm,
       CASE WHEN exon_loc.is_reversed = 0 THEN
       exon_loc.coding_end ELSE exon_loc.coding_start END as end,
       decode (exon_loc.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'isDeprecated=' ||  ga.is_deprecated atts 
FROM   
       ApidbTuning.FeatureLocation exon_loc, ApidbTuning.GeneAttributes ga
WHERE  exon_loc.na_sequence_id = $srcfeature_id
  and  exon_loc.feature_type = 'ExonFeature'
  AND  (( exon_loc.is_reversed = 0 AND exon_loc.coding_start <= $rend+1000 AND  exon_loc.coding_end >= $base_start-1000)
    OR   (exon_loc.is_reversed = 1 AND exon_loc.coding_end <= $rend+1000 AND  exon_loc.coding_start >= $base_start-1000))
  AND ga.na_feature_id = exon_loc.parent_id
UNION
SELECT 
       na_feature_id feature_id, 
       'UTR' type, 
       'annotation' source, 
       na_feature_id name,
       parent_id,
       start_min startm,
       end_max end,
       decode (is_reversed, 0, '+1', 1, '-1', '.') strand,
       'isDeprecated=' ||  is_deprecated atts 
FROM   ApidbTuning.Intron 
WHERE  na_sequence_id = $srcfeature_id
  AND  start_min <= $rend+1000
  AND  end_max >= $base_start-1000
) order by startm
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="gene:JcviPasa:bulksubfeatures">
     <sql>
<![CDATA[
SELECT g3.gff3_feature_id feature_id,
       'exon' type,
       'JcviPasa' source,
       g3.gff3_feature_id name,
       '.' score,
       g3.parent_attr parent_id,
       g3.mapping_start startm,
       g3.mapping_end end,
       decode (g3.is_reversed, 0, '+1', 1, '-1', '.') strand,
       ' ' atts
FROM   apidb.gff3 g3, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
WHERE g3.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND g3.na_sequence_id = $srcfeature_id
  AND g3.mapping_start <= $rend
  AND g3.mapping_end >= $base_start
  AND ed.name = 'TgonME49_JCVI_Reannotation_RSRC'
ORDER BY g3.mapping_start
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="Synteny:syntenyOrg:attribute:Ortholog" includeProjects="FungiDB">
    <sql>
<![CDATA[
select ga2.source_id 
from apidbtuning.geneattributes ga1, apidbtuning.geneattributes ga2
where ga1.source_id = '$name'
and ga1.orthomcl_name = ga2.orthomcl_name
and not ga2.source_id = ga1.source_id
]]>
 </sql>
 </sqlQuery>



  <sqlQuery name="gene:syntenyMC:attribute:Ortholog" excludeProjects="TrichDB">
    <testParamValues project="ToxoDB">
      <param name="name" value="TGME49_039250"/> 
    </testParamValues>
    <testParamValues project="TriTrypDB">
      <param name="name" value="LmjF05.1010"/>
    </testParamValues>
    <testParamValues project="PlasmoDB">
      <param name="name" value="PF11_0344"/>
    </testParamValues>
    <testParamValues project="CryptoDB">
      <param name="name" value="cgd7_230"/>
    </testParamValues>
    <sql>
<![CDATA[
select ga2.source_id 
from ApidbTuning.GeneAttributes ga1, ApidbTuning.GeneAttributes ga2
where ga1.source_id = '$name'
and ga1.orthomcl_name = ga2.orthomcl_name
and not ga2.source_id = ga1.source_id
]]>
 </sql>
 </sqlQuery>
  
  
  <sqlQuery name="alignment:DoTSAssemblies:bulksubfeatures" excludeProjects="TrichDB">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type,
       'DoTSAssemblies' source,
       a.source_id name, 
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM
       ApidbTuning.BlatAlignmentLocation blat,
       dots.Assembly a
WHERE
       blat.query_na_sequence_id = a.na_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
--       (blat.target_end - blat.target_start ) < 5000 and 
       blat.is_best_alignment = 1 and
       blat.target_na_sequence_id = $srcfeature_id
ORDER BY
       blat.target_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="alignment:EST:bulksubfeatures">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type,
       'EST' source,
       est.accession name,
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM   
       ApidbTuning.BlatAlignmentLocation blat, 
       dots.ASSEMBLYSEQUENCE asbl, 
       dots.EST est, 
       dots.NASEQUENCE etn
WHERE  
       blat.query_na_sequence_id = asbl.na_sequence_id and 
       blat.target_na_sequence_id = etn.na_sequence_id and 
       est.na_sequence_id = asbl.na_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       (blat.target_end - blat.target_start ) < 5000 and 
       blat.is_best_alignment = 1 and
       etn.na_sequence_id = $srcfeature_id 
       ORDER BY blat.target_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="gene:annotation:attribute:Ortholog" excludeProjects="TrichDB">
    <testParamValues project="ToxoDB">
      <param name="name" value="TGME49_039250"/>           
    </testParamValues>
    <testParamValues project="TriTrypDB">
      <param name="name" value="LmjF05.1010"/>
    </testParamValues>
    <testParamValues project="PlasmoDB">
      <param name="name" value="PF11_0344"/>
    </testParamValues>
    <testParamValues project="CryptoDB">
      <param name="name" value="cgd7_230"/>
    </testParamValues>
    <sql>
<![CDATA[
select ga2.source_id 
from ApidbTuning.GeneAttributes ga1, ApidbTuning.GeneAttributes ga2
where ga1.source_id = '$name'
and ga1.orthomcl_name = ga2.orthomcl_name
and not ga2.source_id = ga1.source_id
]]>
  </sql>
 </sqlQuery>


<!--
  <sqlQuery name="domain:MassSpecPeptide:bulksubfeatures">
     <sql>
<![CDATA[
SELECT  msf.na_feature_id as feature_id,
        'Peptide' type,
        '$source' as source,
        fl.start_min as startm,
        fl.end_max as end,
        fl.na_feature_id as parent_id,
        decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
        'ExtDbName=' || ed.name atts
 FROM dots.MassSpecFeature msf, ApidbTuning.FeatureLocation fl,
       sres.externaldatabaserelease edr, sres.externaldatabase ed
 WHERE msf.na_feature_id = fl.na_feature_id
  AND  fl.start_min >= $base_start 
  AND  fl.end_max <= $rend
  AND  fl.na_sequence_id = $srcfeature_id
  AND  msf.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name $$edName$$
]]>
    </sql>
  </sqlQuery>
-->  
   <sqlQuery name="UnifiedMassSpecPeptides:density:bulksubfeatures"> 
   <sql> 
<![CDATA[ 
SELECT interval feature_id, 
       na_sequence_id as parent_id,
      'UnifiedMassSpecPeptides' type, 
      'density' source,
      count(interval) score, 
      interval * 50 startm, 
      (interval + 1) * 50 end,
      'score=' || count(interval) atts
FROM ( SELECT ceil(nal.start_min /50) interval, nal.na_sequence_id
 FROM  dots.massspecfeature msf,
       ApidbTuning.FeatureLocation nal,
       dots.nasequence enas
 WHERE msf.na_feature_id = nal.na_feature_id
  AND  nal.na_sequence_id = $srcfeature_id
  AND  enas.na_sequence_id = $srcfeature_id
  AND  nal.start_min >= $base_start
  AND  nal.end_max <= $rend
 ORDER BY nal.start_min)
GROUP BY interval, na_sequence_id
]]> 
    </sql> 
  </sqlQuery>
 
  <sqlQuery name="match:TGI:bulksubfeatures" excludeProjects="TriTrypDB,CryptoDB,GiardiaDB,TrichDB">
    <testParamValues project="ToxoDB">
      <param name="srcfeature_id" value="$$na_seq_id_scf_1107000999720$$"/>
      <param name="rend" value="70824"/>
      <param name="base_start" value="66116"/>
    </testParamValues>
    <testParamValues project="PlasmoDB">
      <param name="srcfeature_id" value="928098"/>
      <param name="rend" value="50"/>
      <param name="base_start" value="1"/>
    </testParamValues>
     <sql>
<![CDATA[
 SELECT
       hsp.similarity_span_id feature_id,
       hsp.similarity_id parent_id,
       'HSP' type, 
       'TGI' source, 
       query.source_id name, 
       '' phase, 
       hsp.number_positive / hsp.match_length score, 
       hsp.subject_start startm,            
       hsp.subject_end end, 
       decode (hsp.is_reversed, 0, '-1', 1, '+1', '.') strand,
       'QStart=' || hsp.query_start || '$dlm' ||
       'QEnd=' || hsp.query_end  atts 
FROM   
       dots.similarity hit,
       dots.similarityspan hsp,
       dots.nasequence query
WHERE  
       hit.similarity_id = hsp.similarity_id and
       query.na_sequence_id = hit.query_id and
       hit.min_subject_start <= $rend and 
       hit.max_subject_end >= $base_start and 
       hit.subject_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="alignment:BLAT:bulksubfeatures">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type,
       'BLAT' source,
       est.accession name,
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM   ApidbTuning.BlatAlignmentLocation blat, 
       dots.ASSEMBLYSEQUENCE asbl,
       dots.EST est,
       dots.NASEQUENCE etn
WHERE  blat.query_na_sequence_id = asbl.na_sequence_id and
       blat.target_na_sequence_id = etn.na_sequence_id and
       est.na_sequence_id = asbl.na_sequence_id and
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       (blat.target_end - blat.target_start ) < 5000 and 
       blat.is_best_alignment = 1 and
       etn.na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>
  


    <sqlQuery name="proteinAlignment:BLAT:bulksubfeatures">
     <sql>
<![CDATA[
SELECT blat.blat_protein_alignment_id feature_id,
       'block' type, 
       'BLAT' source,
       eaas.source_id as name, 
       blat.score || '' score,
       blat.blat_protein_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM
       ApiDBTuning.BlatProtAlignLocation blat, 
       DOTS.externalaasequence eaas
WHERE  blat.query_aa_sequence_id = eaas.aa_sequence_id and
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       (blat.target_end - blat.target_start ) < 5000 and 
       blat.target_na_sequence_id = $srcfeature_id
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="alignment:Bacs:bulksubfeatures" includeProjects="ToxoDB,TriTrypDB">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id, 
'bac_end' type,
'Bacs' source,
etn.source_id name, 
CASE WHEN tn.name like 'Leishmania%' OR tn.name like 'Trypanosoma%'
              THEN regexp_substr(etn.source_id, '(.*)[^(d_T7\.(1-2)|L)(d_SP6\.1|R)]')
     WHEN tn.name like 'Toxoplasma%'
              THEN regexp_substr(etn.source_id, '(.*)[^(q|p)1c)]') 
END parent_id,
blat.score, 
blat.target_start startm,
blat.target_end end,
'pct=' || blat.percent_identity atts
FROM ApidbTuning.BlatAlignmentLocation blat,
dots.ExternalNASequence etn, sres.taxonname tn
WHERE blat.query_na_sequence_id = etn.na_sequence_id
AND etn.taxon_id = tn.taxon_id
AND tn.name_class = 'scientific name'
AND blat.target_na_sequence_id = $srcfeature_id
AND blat.target_start <= $rend 
AND blat.target_end >= $base_start - 1
AND blat.is_best_alignment = 1
AND (blat.target_end - blat.target_start ) < 5000
AND (tn.name like 'Toxoplasma%' OR blat.number_of_spans =1)
AND etn.external_database_release_id in (
SELECT edr.external_database_release_id
FROM sres.EXTERNALDATABASE ed, sres.EXTERNALDATABASERELEASE edr
WHERE ed.external_database_id=edr.external_database_id
AND ed.name in ('Lmajor_sanger_BACEnds_RSRC',
                'Tbrucei_Genbank_BACEnds_RSRC',
                'Tcruzi_BACEnds_RSRC',
                'Lmajor_sanger_PACEnds_RSRC',
                'tgonME49_Sanger_BAC_ends_clonedInsertEnds_RSRC'))
]]>
    </sql>
  </sqlQuery>
  

  <sqlQuery name="annotation:density:subfeatures">
   <testParamValues project="TriTrypDB">
    <param name="parent_id" parentFeatureTest="annotation:density"/>
   </testParamValues>
   <testParamValues project="ToxoDB">
      <param name="parent_id" value="$$na_seq_id_VI$$"/>
   </testParamValues>
   <testParamValues project="PlasmoDB">
    <param name="parent_id" parentFeatureTest="annotation:density"/>
   </testParamValues>
   <testParamValues project="CryptoDB">
    <param name="parent_id" parentFeatureTest="annotation:density"/>
   </testParamValues>
   <testParamValues project="GiardiaDB">
    <param name="parent_id" parentFeatureTest="annotation:density"/>
   </testParamValues> 
   <testParamValues project="TrichDB">
    <param name="parent_id" parentFeatureTest="annotation:density"/>
   </testParamValues>
     <sql>
<![CDATA[
SELECT interval feature_id, 
      'annotation' type, 
      'density' source, 
      count(interval) score, 
      (interval - 1) * 50000 startm, 
      interval * 50000 end 
FROM ( 
      SELECT ceil(fl.start_min / 50000) interval 
      FROM   ApidbTuning.GeneAttributes gf, ApidbTuning.FeatureLocation fl

      WHERE  gf.na_feature_id = fl.na_feature_id and 
             fl.na_sequence_id = $parent_id 
      ORDER BY fl.start_min) 
GROUP BY interval 
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="ORF:density:bulksubfeatures" excludeProjects="ToxoDB,CryptoDB,GiardiaDB"> 
    <sql> 
<![CDATA[ 
SELECT interval feature_id, 
       na_sequence_id as parent_id,
      'ORF' type, 
      'density' source,
      count(interval) score, 
      interval * 500 startm, 
      (interval + 1) * 500 end,
      'score=' || count(interval) atts
FROM ( 
   SELECT ceil(start_min /500) interval, na_sequence_id
   FROM   ApidbTuning.FeatureLocation 
   WHERE  end_max - start_min + 1 >= $$minLength$$
      AND na_sequence_id = $srcfeature_id
      AND start_min >= $base_start - 1 
      AND end_max <= $rend
ORDER BY start_min)
GROUP BY interval, na_sequence_id
]]> 
    </sql> 
  </sqlQuery> 


  <sqlQuery name="SNP:Diversity:bulksubfeatures"  includeProjects="PlasmoDB,ToxoDB">
     <sql>
<![CDATA[
SELECT 
       gff3.gff3_feature_id          as feature_id,
       'SNP_sub'                     as type, 
       '$source'                     as source, 
       gff3.score                    as score, 
       gff3.na_sequence_id           as parent_id, 
       gff3.mapping_start            as startm, 
       gff3.mapping_end              as end, 
       decode(gff3.is_reversed, 0, '+1', 1, '-1', '.') as strand
FROM   ApiDB.GFF3 gff3,
       sres.ExternalDatabase ed,
       sres.ExternalDatabaseRelease edr
WHERE  ed.name = $$edname$$
  AND  edr.external_database_id = ed.external_database_id
  AND  gff3.external_database_release_id = edr.external_database_release_id
  AND  gff3.na_sequence_id = $srcfeature_id
  AND  gff3.mapping_start <= $rend
  AND  gff3.mapping_end >= $base_start
]]>
    </sql>
  </sqlQuery> 

  <sqlQuery name="alignment:Cosmids:bulksubfeatures" includeProjects="ToxoDB,TriTrypDB">
    <testParamValues project="TriTrypDB">
      <param name="srcfeature_id" value="$$na_feat_id_LmjF24_01_20050601_V5.2$$"/>
      <param name="rend" value="204367"/>
      <param name="base_start" value="203962"/>
    </testParamValues>
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id, 
'cosmid_end' type,
'$source' source,
etn.source_id name, 
 CASE WHEN tn.name like 'Leishmania%' OR tn.name like 'Trypanosoma%'
         THEN regexp_substr(etn.source_id, '(.*)[^(X)(Y)]')
      WHEN (tn.name like 'Toxoplasma%' AND etn.secondary_identifier IS NOT NULL)
         THEN regexp_substr(etn.secondary_identifier, '(.*)[^_forward|_reverse]')
      WHEN tn.name like 'Toxoplasma%'
         THEN regexp_substr(etn.source_id, '(.*)[^T(V|H)]')
  END parent_id,
blat.score, 
blat.target_start startm,
blat.target_end end,
'pct=' || blat.percent_identity atts
FROM ApidbTuning.BlatAlignmentLocation blat,
dots.ExternalNASequence etn, Sres.TaxonName tn,
sres.EXTERNALDATABASE ed, sres.EXTERNALDATABASERELEASE edr
WHERE blat.query_na_sequence_id = etn.na_sequence_id
AND blat.target_na_sequence_id = $srcfeature_id
AND blat.target_start <= $rend 
AND blat.target_end >= $base_start - 1
AND blat.is_best_alignment = 1
AND (blat.target_end - blat.target_start ) < 5000
AND (tn.name like 'Toxoplasma%' OR blat.number_of_spans =1)
AND ed.external_database_id=edr.external_database_id
AND edr.external_database_release_id = etn.external_database_release_id
AND etn.taxon_id = tn.taxon_id
AND tn.name_class = 'scientific name'
AND ed.name = $$edName$$
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="gene:syntenyMC:bulksubfeatures" excludeProjects="TrichDB">
     <sql>
<![CDATA[
SELECT -- slow query for all other views
* FROM (SELECT
       exfloc.na_feature_id feature_id,
       'CDS' type, 
       'syntenyMC' source, 
       exfloc.na_feature_id as name,
       exfloc.parent_id,
       apidb.compute_startm (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                             anch_left.ref_loc, anch_right.ref_loc,
                             anch_left.syntenic_loc, anch_right.syntenic_loc,
                             syn.b_start, syn.b_end) startm,
       apidb.compute_end (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                          anch_left.ref_loc, anch_right.ref_loc,
                          anch_left.syntenic_loc, anch_right.syntenic_loc,
                          syn.b_start, syn.b_end) end,
       CASE WHEN (exfloc.is_reversed = syn.is_reversed) THEN 1 ELSE -1 END strand,
       'isDeprecated=' ||  ga.is_deprecated atts 
FROM 
       apidb.synteny syn,
       apidb.syntenyAnchor anch_left,
       apidb.syntenyAnchor anch_right,
       ApidbTuning.FeatureLocation exfloc,
       ApidbTuning.GeneAttributes ga
WHERE ga.na_feature_id = exfloc.parent_id
  AND syn.a_na_sequence_id = $srcfeature_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start 
  AND anch_left.synteny_id = syn.synteny_id 
  AND anch_left.prev_ref_loc < $base_start 
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND anch_left.ref_loc != anch_right.ref_loc
  AND exfloc.feature_type = 'ExonFeature'
  AND exfloc.na_sequence_id = syn.b_na_sequence_id 
  AND (
       (syn.is_reversed = 0
        -- test that the divisor used in synteny scaling is nonzero. It's odd
        -- that this varies with is_reversed. But any changes must happen both
        -- here and in the PL/SQL
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc + 1)>0
        AND apidb.compute_startm (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                                  anch_left.ref_loc, anch_right.ref_loc,
                                  anch_left.syntenic_loc, anch_right.syntenic_loc,
                                  syn.b_start, syn.b_end) <= $rend
        AND apidb.compute_end (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                               anch_left.ref_loc, anch_right.ref_loc,
                               anch_left.syntenic_loc, anch_right.syntenic_loc,
                               syn.b_start, syn.b_end) >= $base_start
       ) 
       OR
       (syn.is_reversed = 1 
        -- test that the divisor used in synteny scaling is nonzero. It's odd
        -- that this varies with is_reversed. But any changes must happen both
        -- here and in the PL/SQL
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc - 1)>0
        AND apidb.compute_startm (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                                  anch_left.ref_loc, anch_right.ref_loc,
                                  anch_left.syntenic_loc, anch_right.syntenic_loc,
                                  syn.b_start, syn.b_end) <= $rend
        AND apidb.compute_end (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                               anch_left.ref_loc, anch_right.ref_loc,
                               anch_left.syntenic_loc, anch_right.syntenic_loc,
                               syn.b_start, syn.b_end) >= $base_start
        )
  )
  AND exfloc.start_min <= syn.b_end
  AND exfloc.end_max >= syn.b_start
UNION
SELECT
       exfloc.na_feature_id feature_id,
       'UTR' type, 
       'syntenyMC' source, 
       exfloc.na_feature_id as name,
       exfloc.parent_id,
       apidb.compute_startm (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                             anch_left.ref_loc, anch_right.ref_loc,
                             anch_left.syntenic_loc, anch_right.syntenic_loc,
                             syn.b_start, syn.b_end) startm,
       apidb.compute_end (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                          anch_left.ref_loc, anch_right.ref_loc,
                          anch_left.syntenic_loc, anch_right.syntenic_loc,
                          syn.b_start, syn.b_end) end,
       CASE WHEN (exfloc.is_reversed = syn.is_reversed) THEN 1 ELSE -1 END strand,
       'isDeprecated=' ||  ga.is_deprecated atts 
FROM 
       apidb.synteny syn,
       apidb.syntenyAnchor anch_left,
       apidb.syntenyAnchor anch_right,
       ApidbTuning.Intron exfloc,
       ApidbTuning.GeneAttributes ga
WHERE ga.na_feature_id = exfloc.parent_id
  AND syn.a_na_sequence_id = $srcfeature_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start 
  AND anch_left.synteny_id = syn.synteny_id 
  AND anch_left.prev_ref_loc < $base_start 
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND anch_left.ref_loc != anch_right.ref_loc
  AND exfloc.na_sequence_id = syn.b_na_sequence_id 
  AND (
       (syn.is_reversed = 0
        -- test that the divisor used in synteny scaling is nonzero. It's odd
        -- that this varies with is_reversed. But any changes must happen both
        -- here and in the PL/SQL
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc + 1)>0
        AND apidb.compute_startm (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                                  anch_left.ref_loc, anch_right.ref_loc,
                                  anch_left.syntenic_loc, anch_right.syntenic_loc,
                                  syn.b_start, syn.b_end) <= $rend
        AND apidb.compute_end (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                               anch_left.ref_loc, anch_right.ref_loc,
                               anch_left.syntenic_loc, anch_right.syntenic_loc,
                               syn.b_start, syn.b_end) >= $base_start
       ) 
       OR
       (syn.is_reversed = 1 
        -- test that the divisor used in synteny scaling is nonzero. It's odd
        -- that this varies with is_reversed. But any changes must happen both
        -- here and in the PL/SQL
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc - 1)>0
        AND apidb.compute_startm (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                                  anch_left.ref_loc, anch_right.ref_loc,
                                  anch_left.syntenic_loc, anch_right.syntenic_loc,
                                  syn.b_start, syn.b_end) <= $rend
        AND apidb.compute_end (syn.is_reversed, exfloc.start_min, exfloc.end_max,
                               anch_left.ref_loc, anch_right.ref_loc,
                               anch_left.syntenic_loc, anch_right.syntenic_loc,
                               syn.b_start, syn.b_end) >= $base_start
        )
  )
  AND exfloc.start_min <= syn.b_end
  AND exfloc.end_max >= syn.b_start
UNION
-- for: reference organism - gene
SELECT
       exfloc.na_feature_id feature_id,
       'CDS' type, 
       'syntenyMC' source, 
       exfloc.na_feature_id as name,
       exfloc.parent_id,
       CASE WHEN exfloc.is_reversed = 0 THEN
         exfloc.coding_start ELSE exfloc.coding_end END as startm,
       CASE WHEN exfloc.is_reversed = 0 THEN
         exfloc.coding_end ELSE exfloc.coding_start END as end,
       decode (exfloc.is_reversed, 0, +1, 1, -1,+1) strand,
       'isDeprecated=' ||  ga.is_deprecated atts 
FROM 
       ApidbTuning.FeatureLocation exfloc,
       ApidbTuning.GeneAttributes ga
WHERE ga.na_sequence_id = $srcfeature_id
  AND ga.start_min <= $rend
  AND ga.end_max >= $base_start
  AND ga.na_feature_id = exfloc.parent_id
  AND exfloc.na_sequence_id = ga.na_sequence_id  
  AND exfloc.feature_type = 'ExonFeature'
UNION
-- for: reference organism - gene
SELECT
       na_feature_id feature_id,
       'UTR' type, 
       'syntenyMC' source, 
       na_feature_id as name,
       parent_id,
       start_min startm,
       end_max end,
       decode (is_reversed, 0, +1, 1, -1,+1) strand,
       'isDeprecated=' ||  is_deprecated atts 
FROM 
       ApidbTuning.Intron
WHERE na_sequence_id = $srcfeature_id
  AND start_min <= $rend
  AND end_max >= $base_start
)
WHERE startm <= $rend
  AND end >= $base_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="Synteny:syntenyOrg:bulksubfeatures" includeProjects="FungiDB">
     <sql>
<![CDATA[
SELECT 
* FROM (SELECT
       exfloc.na_feature_id feature_id,
       'exon' type, 
       '$source' source, 
       exfloc.na_feature_id as name,
       exfloc.parent_id,
       CASE WHEN (syn.is_reversed = 1) 
         THEN anch_left.ref_loc - ((anch_left.syntenic_loc - (CASE WHEN exfloc.end_max > syn.b_end THEN syn.b_end ELSE exfloc.end_max END)) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
         ELSE anch_left.ref_loc + (((CASE WHEN exfloc.start_min < syn.b_start THEN syn.b_start ELSE exfloc.start_min END) - anch_left.syntenic_loc)  * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)) 
       END startm,
       CASE WHEN (syn.is_reversed = 1) 
         THEN anch_left.ref_loc - ((anch_left.syntenic_loc - (CASE WHEN exfloc.start_min < syn.b_start THEN syn.b_start ELSE exfloc.start_min END)) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
         ELSE anch_left.ref_loc + (((CASE WHEN exfloc.end_max > syn.b_end THEN syn.b_end ELSE exfloc.end_max END) - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))  
       END end,
       CASE WHEN (exfloc.is_reversed = syn.is_reversed) THEN 1 ELSE -1 END strand,
       'isDeprecated=' ||  ga.is_deprecated atts 
FROM 
       apidb.synteny syn,
       apidb.syntenyAnchor anch_left,
       apidb.syntenyAnchor anch_right,
       apidbtuning.featurelocation exfloc,
       apidbtuning.geneattributes ga
WHERE ga.na_feature_id = exfloc.parent_id
  AND ga.organism = $$organism$$
  AND syn.a_na_sequence_id = $srcfeature_id
  AND syn.a_start <= $rend 
  AND syn.a_end >= $base_start 
  AND anch_left.synteny_id = syn.synteny_id 
  AND anch_left.prev_ref_loc < $base_start 
  AND anch_left.ref_loc >= $base_start
  AND anch_right.synteny_id = syn.synteny_id
  AND anch_right.ref_loc < $rend
  AND anch_right.next_ref_loc >= $rend
  AND anch_left.ref_loc != anch_right.ref_loc
  AND exfloc.feature_type = 'ExonFeature'
  AND exfloc.na_sequence_id = syn.b_na_sequence_id 
  AND (
       (syn.is_reversed = 0
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc + 1)>0
        AND anch_left.ref_loc + ((exfloc.start_min - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)) <= $rend 
        AND anch_left.ref_loc + ((exfloc.end_max - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)) >= $base_start
       ) 
       OR
       (syn.is_reversed = 1 
        AND abs(anch_right.syntenic_loc - anch_left.syntenic_loc - 1)>0
        AND anch_left.ref_loc - ((anch_left.syntenic_loc - exfloc.end_max) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1)) <= $rend 
        AND anch_left.ref_loc - ((anch_left.syntenic_loc - exfloc.start_min) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1)) >= $base_start
        )
  )
  AND exfloc.start_min <= syn.b_end
  AND exfloc.end_max >= syn.b_start
)
WHERE startm <= $rend
  AND end >= $base_start
]]>
    </sql>
  </sqlQuery>  



  <sqlQuery name="match:WU_BLASTX:bulksubfeatures">
     <sql>
<![CDATA[
 SELECT sim.similarity_span_id feature_id, 
       sim.similarity_id as parent_id,
       'HSP' type, 
       'WU_BLASTX' source, 
       sim.similarity_span_id name, 
       '.' phase, 
       sim.span_score || '' score, 
       sim.query_start startm, 
       sim.query_end end, 
       decode (sim.span_is_reversed, 0, '+1', 1, '-1', '.') strand, 
       '' atts 
FROM   ApidbTuning.SimilaritySpanLocation sim
WHERE  sim.query_id = $srcfeature_id
AND    (sim.max_query_end - sim.min_query_start) < 5000
AND    to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) < 1e-10 
AND    sim.min_query_start >= $base_start 
AND    sim.max_query_end <= $rend
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="alignment:dbEST:bulksubfeatures">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type,
       'dbEST' source,
       est.accession name,
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM
       ApidbTuning.BlatAlignmentLocation blat,
       dots.EST est,
       dots.EXTERNALNASEQUENCE etn
WHERE  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  blat.target_na_sequence_id = $srcfeature_id
  AND  est.na_sequence_id = blat.query_na_sequence_id
  AND  etn.na_sequence_id = est.na_sequence_id
ORDER BY
       blat.target_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="SAGE:3-5prime:bulkAttribute" excludeProjects="CryptoDB,TrichDB,TriTrypDB">
     <sql>
<![CDATA[
 SELECT fl.na_feature_id as feature_id,
       staa.library_name,
       staa.raw_count,
       staa.library_tag_percentage
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SageTagAnalysisAttributes staa,
       ApidbTuning.SageTagAttributes sta,
       rad.assay a
WHERE  fl.feature_type ='SAGETagFeature'
  AND  fl.na_sequence_id = $srcfeature_id 
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  fl.na_feature_id = sta.na_feature_id
  AND  staa.library_name = a.name
  AND  to_number(fl.feature_source_id) = staa.composite_element_id
ORDER BY feature_id, a.assay_id
]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="SAGE:3-5prime:bulkAttribute" includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT fl.na_feature_id as feature_id,
       staa.library_name,
       staa.raw_count,
       staa.library_tag_percentage
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SageTagAnalysisAttributes staa,
       ApidbTuning.SageTagAttributes sta,
       rad.assay a
WHERE  fl.feature_type ='SAGETagFeature'
  AND  fl.na_sequence_id = $srcfeature_id 
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  fl.na_feature_id = sta.na_feature_id
  AND  staa.library_name = a.name
  AND  staa.library_name in ('procyclic_gambiense', 'bloodstream_gambiense') 
  AND  to_number(fl.feature_source_id) = staa.composite_element_id
ORDER BY feature_id, a.assay_id
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="alignment:BLAT:seq" excludeProjects="PlasmoDB,TriTrypDB,ToxoDB">
     <sql>
<![CDATA[
SELECT est.na_sequence_id, est.source_id, est.sequence
FROM   DOTS.NASEQUENCE est
WHERE  est.source_id = '$name'
]]>
    </sql>
  </sqlQuery>
  
<!--  
  <sqlQuery name="clusteralignment:EstCluster:bulksubfeatures">
     <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id, 
       'block' type, 
       'EstCluster' source, 
       a.source_id name, 
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM
       ApidbTuning.BlatAlignmentLocation blat,
       dots.Assembly a
WHERE
       blat.query_na_sequence_id = a.na_sequence_id and 
       blat.target_start <= $rend and 
       blat.target_end >= $base_start and 
       (blat.target_end - blat.target_start ) < 5000 and 
       blat.is_best_alignment = 1 and
       blat.target_na_sequence_id = $srcfeature_id
ORDER BY
       blat.target_start
]]>
    </sql>
  </sqlQuery>
  -->
  
  <sqlQuery name="scaffold:genome:bulksubfeatures" includeProjects="PlasmoDB,ToxoDB,TriTrypDB,GiardiaDB">
     <sql>
<![CDATA[
SELECT sg.na_feature_id as feature_id,
       'gap' type,
       'genome' source,
       sg.source_id name,
       'g.' || vs.na_sequence_id parent_id,
       fl.start_min as startm,
       fl.end_max as end,
       '0' as strand,
       'Type=sgap' as atts
FROM   DoTS.ScaffoldGapFeature sg,
       DoTS.NaLocation fl,
       ApidbTuning.SequenceAttributes vs
       --DoTS.SequencePiece sp
WHERE  fl.na_feature_id = sg.na_feature_id
   AND vs.na_sequence_id = sg.na_sequence_id
   AND vs.na_sequence_id = $srcfeature_id
   AND fl.start_min < $rend 
   AND fl.end_max > $base_start
]]>
    </sql>
  </sqlQuery>

  
  <sqlQuery name="gene:AlternateModels:bulksubfeatures">
     <sql>
<![CDATA[
SELECT
       fl.na_feature_id feature_id, 
       'exon' type, 
       '$source' source, 
       fl.na_feature_id name,
       gf.na_feature_id parent_id, 
       '.' score, 
       fl.start_min startm,            
       fl.end_max end, 
       ed.name||':'||edr.version external_database_name,
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'SecondaryScore=' || gf.secondary_score || '$dlm' ||
       'isDeprecated=' ||  ga.is_deprecated atts 
FROM   
      dots.GeneFeature gf,
       ApidbTuning.FeatureLocation fl,
       ApidbTuning.FeatureLocation fl_gf,
       sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed,
       ApidbTuning.GeneAttributes ga
WHERE  fl.na_sequence_id = $srcfeature_id
  AND  fl.feature_type = 'ExonFeature'
  AND  gf.na_feature_id = fl.parent_id
  AND  fl_gf.na_feature_id = gf.na_feature_id
  AND  fl_gf.start_min <= $rend
  AND  fl_gf.end_max >= $base_start
  AND  gf.external_database_release_id = edr.external_database_release_id 
  AND  edr.external_database_id = ed.external_database_id 
  AND  fl_gf.na_sequence_id = fl.na_sequence_id
  AND  ga.na_feature_id (+) = fl.parent_id
  AND  ed.name = $$extDbName$$ 
ORDER BY 
       fl.start_min
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="gene:OldModels:bulksubfeatures" includeProjects="PlasmoDB,ToxoDB">
  <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type, 
       '$source' source, 
       enas.source_id  name, 
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM   ApidbTuning.BlatAlignmentLocation blat, 
       dots.externalnasequence enas,
       dots.NASEQUENCE etn,
       SRes.ExternalDatabase ed, sres.ExternalDatabaseRelease edr 
WHERE  blat.query_na_sequence_id = enas.na_sequence_id
  AND  blat.target_na_sequence_id = etn.na_sequence_id
  AND  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  blat.is_best_alignment = 1
  AND  etn.na_sequence_id = $srcfeature_id
  AND  enas.external_database_release_id = edr.external_database_release_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name $$oldTranscriptEdName$$
ORDER BY blat.target_start
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="alignment:sequence:bulksubfeatures" includeProjects="CryptoDB">
  <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type, 
       '$source' source, 
       enas.source_id  name, 
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES,
       ' ' atts
FROM   ApidbTuning.BlatAlignmentLocation blat, 
       dots.externalnasequence enas,
       dots.NASEQUENCE etn,
       SRes.ExternalDatabase ed, sres.ExternalDatabaseRelease edr 
WHERE  blat.query_na_sequence_id = enas.na_sequence_id
  AND  blat.target_na_sequence_id = etn.na_sequence_id
  AND  blat.target_start <= $rend
  AND  blat.target_end >= $base_start
  AND  blat.is_best_alignment = 1
  AND  etn.na_sequence_id = $srcfeature_id
  AND  enas.external_database_release_id = edr.external_database_id
  AND  edr.external_database_id = ed.external_database_id
  AND  ed.name $$edName$$
ORDER BY blat.target_start
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="match:syntenySpanMC:bulksubfeatures" excludeProjects="CryptoDB,TrichDB,FungiDB">
    <testParamValues project="TriTrypDB">
      <param name="srcfeature_id" value="$$na_feat_id_TcChr7-S$$"/>
      <param name="rend" value="564285"/>
      <param name="base_start" value="108690"/>
    </testParamValues>
  <sql>
<![CDATA[
SELECT * FROM (
SELECT /*+ ordered */
       fl.na_feature_id feature_id,
       'gap' type,
       'syntenyGap' source,
       fl.na_feature_id name,
       anch_left.synteny_id || '_gap' parent_id,
      CASE WHEN (syn.is_reversed = 1)
        THEN anch_left.ref_loc - ((anch_left.syntenic_loc - fl.end_max) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
        ELSE anch_left.ref_loc + ((fl.start_min - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
        END startm,
        CASE WHEN (syn.is_reversed = 1)
        THEN anch_left.ref_loc - ((anch_left.syntenic_loc - fl.start_min) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
        ELSE anch_left.ref_loc + ((fl.end_max - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
        END end,
        '0' strand,
        'Type=sgap' atts
FROM    apidb.synteny syn,
        ApidbTuning.FeatureLocation fl,
        apidb.syntenyAnchor anch_right,
        apidb.syntenyAnchor anch_left
WHERE  syn.a_na_sequence_id = $srcfeature_id
   AND syn.a_start <= $rend
   AND syn.a_end >= $base_start
   AND anch_left.synteny_id = syn.synteny_id
   AND anch_left.prev_ref_loc < $base_start
   AND anch_left.ref_loc >= $base_start
   AND anch_right.synteny_id = syn.synteny_id
   AND anch_right.ref_loc < $rend
   AND anch_right.next_ref_loc >= $rend
   AND fl.na_sequence_id = syn.b_na_sequence_id
   AND fl.feature_type = 'ScaffoldGapFeature'
   AND fl.IS_TOP_LEVEL = 1
   AND (
    (syn.is_reversed = 0
  AND (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)>0
     AND anch_left.ref_loc + ((fl.start_min - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)) <= $rend
     AND anch_left.ref_loc + ((fl.end_max - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)) >= $base_start
  )
  OR
  (syn.is_reversed = 1
  AND (anch_right.syntenic_loc - anch_left.syntenic_loc - 1)>0
  AND anch_left.ref_loc + ((anch_left.syntenic_loc - fl.end_max) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc - 1)) <= $rend
  AND anch_left.ref_loc + ((anch_left.syntenic_loc - fl.start_min) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc - 1)) >= $base_start
  )
  )
  AND fl.start_min <= syn.b_end
  AND fl.end_max >= syn.b_start
)
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="Synteny:syntenySpanOrg:bulksubfeatures" includeProjects="FungiDB">
  <sql>
<![CDATA[
SELECT * FROM (
SELECT /*+ ordered */
       fl.na_feature_id feature_id,
       'gap' type,
       'syntenyGap' source,
       fl.na_feature_id name,
       anch_left.synteny_id || '_gap' parent_id,
      CASE WHEN (syn.is_reversed = 1)
        THEN anch_left.ref_loc - ((anch_left.syntenic_loc - fl.end_max) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
        ELSE anch_left.ref_loc + ((fl.start_min - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
        END startm,
        CASE WHEN (syn.is_reversed = 1)
        THEN anch_left.ref_loc - ((anch_left.syntenic_loc - fl.start_min) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc - 1))
        ELSE anch_left.ref_loc + ((fl.end_max - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1))
        END end,
        '0' strand,
        'Type=sgap' atts
FROM    apidb.synteny syn,
        apidbtuning.featurelocation fl,
        apidb.syntenyAnchor anch_right,
        apidb.syntenyAnchor anch_left
WHERE  syn.a_na_sequence_id = $srcfeature_id
   AND syn.a_start <= $rend
   AND syn.a_end >= $base_start
   AND anch_left.synteny_id = syn.synteny_id
   AND anch_left.prev_ref_loc < $base_start
   AND anch_left.ref_loc >= $base_start
   AND anch_right.synteny_id = syn.synteny_id
   AND anch_right.ref_loc < $rend
   AND anch_right.next_ref_loc >= $rend
   AND fl.na_sequence_id = syn.b_na_sequence_id
   AND fl.feature_type = 'ScaffoldGapFeature'
   AND fl.IS_TOP_LEVEL = 1
   AND (
    (syn.is_reversed = 0
  AND (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)>0
     AND anch_left.ref_loc + ((fl.start_min - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)) <= $rend
     AND anch_left.ref_loc + ((fl.end_max - anch_left.syntenic_loc) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_right.syntenic_loc - anch_left.syntenic_loc + 1)) >= $base_start
  )
  OR
  (syn.is_reversed = 1
  AND (anch_right.syntenic_loc - anch_left.syntenic_loc - 1)>0
  AND anch_left.ref_loc + ((anch_left.syntenic_loc - fl.end_max) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc - 1)) <= $rend
  AND anch_left.ref_loc + ((anch_left.syntenic_loc - fl.start_min) * (anch_right.ref_loc - anch_left.ref_loc + 1) / (anch_left.syntenic_loc - anch_right.syntenic_loc - 1)) >= $base_start
  )
  )
  AND fl.start_min <= syn.b_end
  AND fl.end_max >= syn.b_start
)
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="SNP:density:subfeatures"  includeProjects="ToxoDB">
   <testParamValues project="ToxoDB">
        <param name="parent_id" value="$$na_seq_id_VI$$"/>
   </testParamValues> 
     <sql>
<![CDATA[
 SELECT interval feature_id, 
      'SNP' type, 
      'density' source, 
      count(interval) score, 
      (interval - 1) * 50000 startm, 
      interval * 50000 end 
FROM (
      SELECT ceil(fl.start_min/ 50000) interval
      FROM   dots.seqVariation sv, ApidbTuning.SnpAttributes sa, ApidbTuning.FeatureLocation fl
      WHERE  sv.parent_id = fl.na_feature_id
       AND   fl.na_feature_id = sa.na_feature_id
       AND   fl.na_sequence_id = $parent_id
      ORDER BY fl.start_min )
GROUP BY interval
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="GeneticMarkers:Sibley:bulkAttribute"  includeProjects="ToxoDB">
    <testParamValues project="ToxoDB">
       <param name="srcfeature_id" value="$$na_seq_id_X$$"/>
       <param name="rend" value="6929962"/>
       <param name="base_start" value="6766705"/>
    </testParamValues>
     <sql>
<![CDATA[
SELECT    sa.na_feature_id as feature_id,
          var.strain,
          var.allele,
          var.phenotype,
          var.product
FROM ApidbTuning.SnpAttributes sa,
     dots.SeqVariation var,
     ApidbTuning.FeatureLocation fl
WHERE fl.na_sequence_id = $srcfeature_id
  AND fl.start_min <= $rend
  AND fl.start_min >= $base_start
  AND  fl.na_feature_id = sa.na_feature_id
  AND sa.dataset = 'Genetic Markers - David Sibley'
  AND var.parent_id = fl.na_feature_id
 ORDER BY var.strain
 
]]>
    </sql>
  </sqlQuery>
 



 
  <sqlQuery name="CGH:CNV:bulksubfeatures">
     <sql>
<![CDATA[
SELECT   feature_id, 
         '$source' as source, 
         parent_id, 
         'CGH' as type,
         startm, 
         end, 
         CASE WHEN direction = 'deletion' THEN  -1*count(*) ELSE count(*) END as score,
         'Direction=' || direction  atts 
FROM    (SELECT  mapping_start as feature_id,
                 NA_SEQUENCE_ID as parent_id,
                 mapping_start as startm, 
                 mapping_end as end, 
                 SCORE as score,
                 CASE WHEN SCORE < 0 THEN 'deletion'  ELSE 'amplification' END as direction,
                 decode (is_reversed, 0, '+1', 1, '-1', '.') as strand
                   FROM    Apidb.GFF3
                   WHERE   MAPPING_START <= $rend 
                   AND     MAPPING_END >= $base_start 
                   AND     na_sequence_id = $srcfeature_id
         )
GROUP BY feature_id, parent_id, startm,end, direction
HAVING count(*) <= 10
]]> 
    </sql> 
  </sqlQuery>
 


 
  <sqlQuery name="ChIP:TBP_Promastigotes:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT ee.na_feature_id   as feature_id,
       'ChIP_sub'          as type,
       'TBP_Promastigotes'               as source,
       ee.score        as score,
       ee.na_sequence_id     as parent_id,
       ee.start_min           as startm,
       ee.end_max             as end,
       'Treatment=' || cpp.treatment || '$dlm' || 'Analysis=' || a.name|| '$dlm' || 'Antibody=' || cpp.antibody || '$dlm' || 'Rep=' || cpp.genotype as atts
FROM   rad.protocol p,rad.analysis a,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  ee.analysis_id =   cpp.analysis_id
AND    cpp.protocol_id =  p.protocol_id
AND    cpp.analysis_id = a.analysis_id
AND    lower(p.name) like '%myler%'
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(a.name) like '%tbp-replicate%'
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:SNAP50_Promastigotes:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT ee.na_feature_id   as feature_id,
       'ChIP_sub'          as type,
       'SNAP50_Promastigotes'               as source,
       ee.score        as score,
       ee.na_sequence_id     as parent_id,
       ee.start_min           as startm,
       ee.end_max             as end,
       'Treatment=' || cpp.treatment || '$dlm' || 'Analysis=' || a.name|| '$dlm' || 'Antibody=' || cpp.antibody || '$dlm' || 'Rep=' || cpp.genotype as atts
FROM   rad.protocol p,rad.analysis a,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  ee.analysis_id =   cpp.analysis_id
AND    cpp.protocol_id =  p.protocol_id
AND    cpp.analysis_id = a.analysis_id
AND    lower(p.name) like '%myler%'
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(a.name) like '%snap50-replicate%'
]]>
    </sql>
  </sqlQuery>



  <sqlQuery name="ChIP:AcetylH3_Promastigotes:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT ee.na_feature_id   as feature_id,
       'ChIP_sub'          as type,
       'AcetylH3_Promastigotes' as source,
       ee.score        as score,
       ee.na_sequence_id     as parent_id,
       ee.start_min           as startm,
       ee.end_max             as end,
       'Treatment=' || cpp.treatment || '$dlm' || 'Analysis=' || a.name|| '$dlm' || 'Antibody=' || cpp.antibody || '$dlm' || 'Rep=' || cpp.genotype as atts
FROM   rad.protocol p,rad.analysis a,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  ee.analysis_id =   cpp.analysis_id
AND    cpp.protocol_id =  p.protocol_id
AND    cpp.analysis_id = a.analysis_id
AND    lower(p.name) like '%myler%'
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(a.name) like '%acetylh3-replicate%'
]]>
    </sql>
  </sqlQuery>



  <sqlQuery name="ChIP:AcetylH3_Log_vs_Stationary:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT ee.na_feature_id   as feature_id,
       'ChIP_sub'          as type,
       'AcetylH3_Log_vs_Stationary' as source,
       ee.score        as score,
       ee.na_sequence_id     as parent_id,
       ee.start_min           as startm,
       ee.end_max             as end,
       'Treatment=' || cpp.treatment || '$dlm' || 'Analysis=' || a.name|| '$dlm' || 'Antibody=' || cpp.antibody || '$dlm' || 'Rep=' || cpp.genotype as atts
FROM   rad.protocol p,rad.analysis a,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  ee.analysis_id =   cpp.analysis_id
AND    cpp.protocol_id =  p.protocol_id
AND    cpp.analysis_id = a.analysis_id
AND    lower(p.name) like '%myler%'
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(a.name) like '%acetylh3%' AND lower(a.name) not like '%replicate%'
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:TBP_Log_vs_Stationary:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
 SELECT ee.na_feature_id   as feature_id,
       'ChIP_sub'          as type,
       'TBP_Log_vs_Stationary' as source,
       ee.score        as score,
       ee.na_sequence_id     as parent_id,
       ee.start_min           as startm,
       ee.end_max             as end,
       'Treatment=' || cpp.treatment || '$dlm' || 'Analysis=' || a.name|| '$dlm' || 'Antibody=' || cpp.antibody || '$dlm' || 'Rep=' || cpp.genotype as atts
FROM   rad.protocol p,rad.analysis a,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  ee.analysis_id =   cpp.analysis_id
AND    cpp.protocol_id =  p.protocol_id
AND    cpp.analysis_id = a.analysis_id
AND    lower(p.name) like '%myler%'
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(a.name) like '%tbp%' AND lower(a.name) not like '%replicate%'
]]>
    </sql>
  </sqlQuery>


  <sqlQuery name="ChIP:ChIPchip:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT  ee.na_feature_id   as feature_id,
       'ChIP'              as type,
       '$source'           as source,
        ee.score           as score,
        p.name || '_' || cpp.antibody  as parent_id,
        ee.start_min       as startm,
        ee.end_max         as end,
       'ProtocolType=' || cpp.protocol_type|| '$dlm' ||
       'Analysis='     || a.name|| '$dlm' ||
       'Antibody='     || cpp.antibody  || '$dlm' ||
       'Rep='          || cpp.replicate || '$dlm' ||
       'Genotype='     || cpp.genotype as atts
FROM   rad.analysis a,rad.protocol p,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  a.analysis_id = cpp.analysis_id
AND    a.protocol_id = p.protocol_id
AND    a.analysis_id = ee.analysis_id
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    cpp.experiment_name = $$exp$$
AND    p.name = $$protocol$$
AND    cpp.protocol_type = 'raw'
   ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="ChIP:ChIPchipSub_Strain:bulksubfeatures"  includeProjects="ToxoDB">
     <sql>
<![CDATA[
SELECT  ee.na_feature_id   as feature_id,
       'ChIP'              as type,
       '$source'           as source,
        ee.score           as score,
        p.name  || '_' || cpp.strain as parent_id,
        ee.start_min       as startm,
        ee.end_max         as end,
       'ProtocolType=' || cpp.protocol_type|| '$dlm' ||
       'Analysis='     || a.name|| '$dlm' ||
       'Antibody='     || cpp.antibody  || '$dlm' ||
       'Rep='          || cpp.replicate || '$dlm' ||
       'Strain='       || cpp.strain || '$dlm' ||
       'Genotype='     || cpp.genotype as atts
FROM   rad.analysis a,rad.protocol p,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  a.analysis_id = cpp.analysis_id
AND    a.protocol_id = p.protocol_id
AND    a.analysis_id = ee.analysis_id
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    cpp.experiment_name = $$exp$$
AND    p.name = $$protocol$$
AND    cpp.protocol_type = 'raw'
   ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="ChIP:ChIPchipSub_Antibody:bulksubfeatures"  includeProjects="PlasmoDB,ToxoDB">
     <sql>
<![CDATA[
SELECT  ee.na_feature_id   as feature_id,
       'ChIP'              as type,
       '$source'           as source,
        ee.score           as score,
        p.name  || '_' || cpp.antibody as parent_id,
        ee.start_min       as startm,
        ee.end_max         as end,
       'ProtocolType=' || cpp.protocol_type|| '$dlm' ||
       'Analysis='     || a.name|| '$dlm' ||
       'Antibody='     || cpp.antibody  || '$dlm' ||
       'Rep='          || cpp.replicate || '$dlm' ||
       'Strain='       || cpp.strain || '$dlm' ||
       'Genotype='     || cpp.genotype as atts
FROM   rad.analysis a,rad.protocol p,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  a.analysis_id = cpp.analysis_id
AND    a.protocol_id = p.protocol_id
AND    a.analysis_id = ee.analysis_id
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    cpp.experiment_name = $$exp$$
AND    p.name = $$protocol$$
AND    cpp.protocol_type = 'raw'
   ]]>
    </sql>
  </sqlQuery>
  
  
  

  <sqlQuery name="ChIP:Schizont_H3K4me3_H3K9ac:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT  ee.na_feature_id   as feature_id,
       'ChIP'              as type, 
       'Schizont_H3K4me3_H3K9ac'          as source, 
        ee.score    as score, 
        ee.na_sequence_id  as parent_id, 
        ee.start_min       as startm, 
        ee.end_max         as end,
       'ProtocolType=' || cpp.protocol_type|| '$dlm' ||
       'Analysis=' || a.name|| '$dlm' ||
       'Antibody='     || cpp.antibody  as atts
FROM   rad.analysis a,rad.protocol p, 
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  a.analysis_id = cpp.analysis_id
AND    a.protocol_id = p.protocol_id
AND    a.analysis_id = ee.analysis_id
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(p.name) like '%stunnenberg%'
AND    a.name like '%Schizont%' and (lower(cpp.antibody) = 'h3k4me3' or lower(cpp.antibody) = 'h3k9ac')
AND    cpp.protocol_type = 'raw'
]]>
    </sql>
  </sqlQuery>



  <sqlQuery name="ChIP:Schizont_H3_cDNA:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT  ee.na_feature_id   as feature_id,
       'ChIP'              as type,
       'Schizont_H3_cDNA'          as source,
        ee.score    as score,
        ee.na_sequence_id  as parent_id,
        ee.start_min       as startm,
        ee.end_max         as end,
       'ProtocolType=' || cpp.protocol_type|| '$dlm' ||
       'Analysis=' || a.name|| '$dlm' ||
       'Antibody='     || cpp.antibody  as atts
FROM   rad.analysis a,rad.protocol p,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  a.analysis_id = cpp.analysis_id
AND    a.protocol_id = p.protocol_id
AND    a.analysis_id = ee.analysis_id
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(p.name) like '%stunnenberg%'
AND    a.name like '%Schizont%' and (lower(cpp.antibody) = 'h3' or lower(a.name) like '%cdna%')
AND    cpp.protocol_type = 'raw'
]]>
    </sql>
  </sqlQuery>





  <sqlQuery name="ChIP:Ring_H3K4me3_H3K9ac:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT  ee.na_feature_id   as feature_id,
       'ChIP'              as type,
       'Ring_H3K4me3_H3K9ac'              as source,
        ee.score    as score,
        ee.na_sequence_id  as parent_id,
        ee.start_min       as startm,
        ee.end_max         as end,
       'ProtocolType=' || cpp.protocol_type|| '$dlm' ||
       'Analysis=' || a.name || '$dlm' ||
       'Antibody='     || cpp.antibody  as atts
FROM   rad.analysis a,rad.protocol p,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  a.analysis_id = cpp.analysis_id
AND    a.protocol_id = p.protocol_id
AND    a.analysis_id = ee.analysis_id
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(p.name) like '%stunnenberg%'
AND    a.name like '%Ring%' and (lower(cpp.antibody) = 'h3k4me3' or lower(cpp.antibody) = 'h3k9ac')
AND    cpp.protocol_type = 'raw'
]]>
    </sql>
  </sqlQuery>



  <sqlQuery name="ChIP:Ring_H3_cDNA:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT  ee.na_feature_id   as feature_id,
       'ChIP'              as type,
       'Ring_H3_cDNA'              as source,
        ee.score    as score,
        ee.na_sequence_id  as parent_id,
        ee.start_min       as startm,
        ee.end_max         as end,
       'ProtocolType=' || cpp.protocol_type|| '$dlm' ||
       'Analysis=' || a.name || '$dlm' ||
       'Antibody='     || cpp.antibody  as atts
FROM   rad.analysis a,rad.protocol p,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  a.analysis_id = cpp.analysis_id
AND    a.protocol_id = p.protocol_id
AND    a.analysis_id = ee.analysis_id
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(p.name) like '%stunnenberg%'
AND    a.name like '%Ring%' and (lower(cpp.antibody) = 'h3' or lower(a.name) like '%cdna%')
AND    cpp.protocol_type = 'raw'
]]>
    </sql>
  </sqlQuery>



  <sqlQuery name="ChIP:Mixed_H3K4me3_H3K9ac:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT  ee.na_feature_id   as feature_id,
       'ChIP'              as type,
       'Mixed_H3K4me3_H3K9ac'        as source,
        ee.score    as score,
        ee.na_sequence_id  as parent_id,
        ee.start_min       as startm,
        ee.end_max         as end,
       'ProtocolType=' || cpp.protocol_type|| '$dlm' ||
       'Analysis=' || a.name || '$dlm' ||
       'Antibody='     || cpp.antibody  as atts
FROM   rad.analysis a,rad.protocol p,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  a.analysis_id = cpp.analysis_id
AND    a.protocol_id = p.protocol_id
AND    a.analysis_id = ee.analysis_id
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(p.name) like '%stunnenberg%'
AND    a.name in ('77620-H3K9ac','79483-H3K4me3','89274-H3K9ac','89876-H3K4me3','96461-H3K9ac')
AND    cpp.protocol_type = 'raw'
   ]]>
    </sql>
  </sqlQuery>
<!--    Using the analysis names directly in the WHERE clause to filter out the probes for each antibody in the above query is probably a little clumsy, but this direct specification is giving a 4 fold improvement in the time taken when compared to using nested WHERE clauses with ORs and AND logicals (see below) -->
<!-- AND    a.name not like '%Schizont%' and a.name not like '%Ring%' and (lower(cpp.antibody) = 'h3k4me3' or lower(cpp.antibody) = 'h3k9ac') -->

  <sqlQuery name="ChIP:Mixed_H3K9me3_H3_cDNA:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT  ee.na_feature_id   as feature_id,
       'ChIP'              as type,
       'Mixed_H3K9me3_H3_cDNA'        as source,
        ee.score    as score,
        ee.na_sequence_id  as parent_id,
        ee.start_min       as startm,
        ee.end_max         as end,
       'ProtocolType=' || cpp.protocol_type|| '$dlm' ||
       'Analysis=' || a.name || '$dlm' ||
       'Antibody='     || cpp.antibody  as atts
FROM   rad.analysis a,rad.protocol p,
       ApidbTuning.ExpressionElement ee,
       ApidbTuning.ChIPProtocolParams cpp
WHERE  a.analysis_id = cpp.analysis_id
AND    a.protocol_id = p.protocol_id
AND    a.analysis_id = ee.analysis_id
AND    ee.na_sequence_id = $srcfeature_id
AND    ee.start_min <= $rend
AND    ee.end_max >= $base_start
AND    lower(p.name) like '%stunnenberg%'
AND    a.name in ('116550-cDNA','4944702-H3K9me3','89272-H3','89877-H3','96481-H3') 
AND    cpp.protocol_type = 'raw'
   ]]>
    </sql>
  </sqlQuery>
<!--    Using the analysis names directly in the WHERE clause to filter out the probes for each antibody in the above query is probably a little clumsy, but this direct specification is giving a 4 fold improvement in the time taken when compared to using nested WHERE clauses with ORs and AND logicals (see below) -->
<!-- a.name not like '%Schizont%' and a.name not like '%Ring%' and (lower(cpp.antibody) = 'h3' or lower(cpp.antibody) = 'h3k9me3' or lower(a.name) like '%cdna%') -->


  <sqlQuery name="ChIP:NucleosomeGB2:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
 SELECT  start_interval    as feature_id,
        'ChIP'             as type,
        '$source'          as source,
        avg(score)         as score,
        name               as parent_id,
        start_interval * (($rend - $base_start + 1) / 800) startm,
        end_interval * (($rend - $base_start + 1) / 800) end,
       'Analysis=' || name as atts
FROM   (select ceil(ee.start_min / (($rend - $base_start + 1) / 800)) start_interval,
               ceil(ee.end_max / (($rend - $base_start + 1) / 800)) end_interval,
               ee.score as score,ee.na_feature_id,
               ee.na_sequence_id,a.name as name 
        from rad.analysis a,
             ApidbTuning.ExpressionElement ee
        WHERE  a.analysis_id = ee.analysis_id
        AND    ee.na_sequence_id = $srcfeature_id
        AND    a.name in ( $$analysis$$ )
        AND    ee.start_min <= $rend
        AND    ee.end_max >= $base_start)
GROUP BY start_interval,end_interval,na_sequence_id,name
   ]]>
    </sql>
  </sqlQuery>

  <sqlQuery name="SNP:Alignment:bulkAttribute" includeProjects="ToxoDB">
     <sql>
<![CDATA[
SELECT    sa.na_feature_id as feature_id,
          var.strain,
          var.allele,
          var.phenotype,
          var.product
FROM ApidbTuning.SnpAttributes sa,
     dots.SeqVariation var,
     ApidbTuning.FeatureLocation fl
WHERE fl.na_sequence_id = $srcfeature_id
  AND fl.start_min <= $rend
  AND fl.start_min >= $base_start
  AND fl.feature_type = 'SnpFeature'
  AND fl.na_feature_id = sa.na_feature_id
  AND sa.dataset = 'tgonME49_SNP_Amit_nucmer_gff_RSRC'
  AND var.parent_id = fl.na_feature_id
 ORDER BY var.strain
 
]]>
    </sql>
  </sqlQuery>
  
   
  <sqlQuery name="htsSNP:Alignment:bulkAttribute" includeProjects="ToxoDB,AmoebaDB,TriTrypDB">
     <sql>
<![CDATA[
SELECT    sa.na_feature_id as feature_id,
          var.strain, var.allele, var.phenotype, var.product,
          var.pvalue, var.coverage, var.allele_percent
FROM ApidbTuning.SnpAttributes sa,
     dots.SeqVariation var,
     ApidbTuning.FeatureLocation fl
WHERE fl.na_sequence_id = $srcfeature_id
  AND fl.start_min <= $rend
  AND fl.start_min >= $base_start
  AND fl.feature_type = 'SnpFeature'
  AND fl.na_feature_id = sa.na_feature_id
  AND sa.dataset = 'InsertSnps.pm NGS SNPs INTERNAL'
  AND var.parent_id = fl.na_feature_id
 ORDER BY var.strain
 
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="mapp:promoters:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT location feature_id, 
             'mapp' type, 
             'promoters' source, 
             '' name, 
             value score, 
             na_sequence_id || '_' || strand parent_id, 
             location startm, 
             location end, 
             strand,
             '' atts
       FROM  ApiDB.plasmoMapp
       WHERE na_sequence_id = $srcfeature_id 
         AND location <= $rend
         AND location >= $base_start - 1 
]]>
    </sql>
  </sqlQuery>
 
  <sqlQuery name="SNP:Combined:density"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
 SELECT etn.na_sequence_id feature_id, 
       'SNP:Combined' type, 
       'density' source 
FROM   dots.ExternalNaSequence etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>
  
  
  <sqlQuery name="SNP:Population:bulkAttribute"  includeProjects="PlasmoDB,ToxoDB">
     <sql>
<![CDATA[
SELECT sa.na_feature_id as feature_id, var.strain, var.allele,
       var.phenotype, var.product
FROM ApidbTuning.SnpAttributes sa,
     dots.SeqVariation var
WHERE sa.dataset = $$edname$$
  AND sa.na_sequence_id = $srcfeature_id
  AND sa.start_min <= $rend
  AND sa.start_min >= $base_start
  AND var.parent_id = sa.na_feature_id
ORDER BY var.strain
]]>
    </sql>
  </sqlQuery>
  
  <sqlQuery name="SNP:Widmer:bulkAttribute" includeProjects="CryptoDB">
    <testParamValues project="CryptoDB">
       <param name="srcfeature_id" value="$$na_seq_id_CM000431$$"/>
       <param name="base_start" value="150000"/>
       <param name="rend" value="152000"/>
    </testParamValues>
     <sql>
<![CDATA[
SELECT sa.na_feature_id as feature_id, UPPER(var.strain) strain, var.allele,
       var.phenotype, var.product
FROM ApidbTuning.SnpAttributes sa,
     dots.SeqVariation var,
     ApidbTuning.FeatureLocation fl
WHERE fl.na_sequence_id = $srcfeature_id
  AND fl.start_min <= $rend
  AND fl.start_min >= $base_start
  AND  fl.na_feature_id = sa.na_feature_id
  AND var.parent_id = fl.na_feature_id
 ORDER BY var.strain
 
]]>
    </sql>
  </sqlQuery>

   <sqlQuery name="DGE:coverage:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
SELECT fl.na_feature_id as feature_id,
       'DGE' type, 
       '$source' source, 
       sta.source_id name, 
       $$sample$$ parent_id, 
       CASE WHEN staa.occurrence > 1 
            THEN decode(log(2,staa.raw_count),0,-0.5,-(log(2,staa.raw_count)))
            ELSE decode(log(2,staa.raw_count),0,0.5,log(2,staa.raw_count))
       END score,
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'binaryColor='||CASE WHEN staa.occurrence > 1 THEN 1 ELSE 0 END atts
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SageTagAnalysisAttributes staa,
       ApidbTuning.SageTagAttributes sta
WHERE  fl.feature_type ='SAGETagFeature'
  AND  fl.na_sequence_id = $srcfeature_id 
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  fl.na_feature_id = sta.na_feature_id
  AND  staa.library_name = $$libName$$
  AND  to_number(fl.feature_source_id) = staa.composite_element_id
]]>
    </sql>
  </sqlQuery>

   <sqlQuery name="DGE:coverageSubtracks:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
SELECT fl.na_feature_id as feature_id,
       'DGE' type, 
       '$source' source, 
       sta.source_id name, 
       --$$sample$$ parent_id, 
       staa.library_name parent_id,
       CASE WHEN staa.occurrence > 1 
            THEN decode(log(2,staa.raw_count),0,-0.5,-(round(log(2,staa.raw_count),2)))
            ELSE decode(log(2,staa.raw_count),0,0.5,round(log(2,staa.raw_count),2))
       END score,
       fl.start_min startm, 
       fl.end_max end, 
       decode (fl.is_reversed, 0, '+1', 1, '-1', '.') strand,
       --'library=' || $$libName$$ || '$dlm' ||
       'binaryColor='||CASE WHEN staa.occurrence > 1 THEN 1 ELSE 0 END as atts
FROM   ApidbTuning.FeatureLocation fl,
       ApidbTuning.SageTagAnalysisAttributes staa,
       ApidbTuning.SageTagAttributes sta
WHERE  fl.feature_type ='SAGETagFeature'
  AND  fl.na_sequence_id = $srcfeature_id 
  AND  fl.start_min <= $rend
  AND  fl.end_max >= $base_start
  AND  fl.na_feature_id = sta.na_feature_id
  --AND  staa.library_name = $$libName$$
  AND  to_number(fl.feature_source_id) = staa.composite_element_id
]]>
    </sql>
  </sqlQuery>

   <sqlQuery name="MicroArrayProbes:expressionH:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
SELECT interval as feature_id,
       $srcfeature_id as parent_id,
       'MicroArrayProbes' type, 
       '$source' source,
       count(interval) score, 
       (interval - 1) * 1000 startm, 
       interval * 1000 end
FROM
(
  SELECT ceil(fl.start_min / 1000) interval 
  FROM   ApidbTuning.FeatureLocation fl, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
  WHERE  edr.external_database_id = ed.external_database_id
    AND  edr.external_database_release_id=fl.external_database_release_id
    AND  fl.feature_type = 'ArrayElementFeature'
    AND  ed.name = $$edname$$
    AND  fl.start_min <= $rend
    AND  fl.end_max >= $base_start
    AND  fl.na_sequence_id = $srcfeature_id
) 
GROUP BY interval
]]>
    </sql>
  </sqlQuery>


   <sqlQuery name="NextGenSeq:coverage:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
     SELECT start_interval feature_id,
             'NextGenSeq' type,
             '$source' source,
              CASE WHEN multiple = 1 THEN -1 * max(coverage) ELSE max(coverage) END score, 
             $$sample$$ parent_id,
             start_interval * (($rend - $base_start + 1) / 800) startm,
             end_interval * (($rend - $base_start + 1) / 800) end,
             'binaryColor='||CASE WHEN multiple = 1 THEN 1 ELSE 0 END atts
    FROM (select ceil((csc.mapping_start + 1) / (($rend - $base_start + 1) / 800)) start_interval, 
                 ceil(csc.mapping_end / (($rend - $base_start + 1) / 800)) end_interval, 
                 csc.coverage, csc.sample,csc.multiple
       FROM  apidb.NextGenSeqCoverage csc,
             sres.externaldatabaserelease edr,
             sres.externaldatabase ed
       WHERE csc.external_database_release_id = edr.external_database_release_id
         AND edr.external_database_id = ed.external_database_id
         AND ed.name = $$edname$$ 
         AND csc.na_sequence_id = $srcfeature_id
         AND csc.sample = $$sample$$
         AND csc.mapping_start + 1 <= $rend
         AND csc.mapping_end >= $base_start - 1)
       GROUP BY start_interval,end_interval,sample,multiple
]]>
    </sql>
  </sqlQuery>



   <sqlQuery name="NextGenSeq:coverageRatio:bulksubfeatures"  includeProjects="TriTrypDB,PlasmoDB">
     <sql>
<![CDATA[
     SELECT num.feature_id, num.type, num.source,
            decode(num.multiple, 1, -1, 1)*(num.score/den.score) score,
             num.parent_id,
             num.startm, num.end, num.atts
     FROM
     (SELECT interval feature_id,
             'NextGenSeq' type,
             '$source' source,
              max(coverage) score, 
             $$numSample$$ parent_id,
             interval * (($rend - $base_start + 1) / 800) startm,
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'binaryColor='||CASE WHEN multiple = 1 THEN 1 ELSE 0 END atts, multiple
    FROM (select ceil(csc.mapping_start / (($rend - $base_start + 1) / 800)) interval, csc.coverage, csc.sample,csc.multiple
       FROM  apidb.NextGenSeqCoverage csc,
             sres.externaldatabaserelease edr,
             sres.externaldatabase ed
       WHERE csc.external_database_release_id = edr.external_database_release_id
         AND edr.external_database_id = ed.external_database_id
         AND ed.name = $$numEdname$$ 
         AND csc.na_sequence_id = $srcfeature_id
         AND csc.sample = $$numSample$$
         AND csc.mapping_start <= $rend
         AND csc.mapping_start >= $base_start - 1)
       GROUP BY interval,sample,multiple) num,
     (SELECT interval feature_id,
             'NextGenSeq' type,
             '$source' source,
              max(coverage) score, 
             $$denSample$$ parent_id,
             interval * (($rend - $base_start + 1) / 800) startm,
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'binaryColor='||CASE WHEN multiple = 1 THEN 1 ELSE 0 END atts, multiple
    FROM (select ceil(csc.mapping_start / (($rend - $base_start + 1) / 800)) interval, csc.coverage, csc.sample,csc.multiple
       FROM  apidb.NextGenSeqCoverage csc,
             sres.externaldatabaserelease edr,
             sres.externaldatabase ed
       WHERE csc.external_database_release_id = edr.external_database_release_id
         AND edr.external_database_id = ed.external_database_id
         AND ed.name = $$denEdname$$ 
         AND csc.na_sequence_id = $srcfeature_id
         AND csc.sample = $$denSample$$
         AND csc.mapping_start <= $rend
         AND csc.mapping_start >= $base_start - 1)
       GROUP BY interval,sample,multiple) den
    WHERE den.feature_id = num.feature_id
      AND den.multiple = num.multiple 
]]>
    </sql>
  </sqlQuery>



   <sqlQuery name="NextGenSeq:coverageCombNormGB2:bulksubfeatures"  includeProjects="PlasmoDB">
    <sql>
    <![CDATA[
SELECT start_interval feature_id,
      'NextGenSeq' type,
      '$source' source,
      CASE WHEN  multiple = 1 THEN -1 * max(round(c.coverage * s.sum_span_length / 15000000,1)) ELSE max(round(c.coverage * s.sum_span_length / 15000000,1)) END as score,
      c.name || '_' || c.sample as parent_id,
      c.start_interval * (($rend - $base_start + 1) / 800) startm,
      c.end_interval * (($rend - $base_start + 1) / 800) end,
      'sample=' || c.sample || '$dlm' ||
      'binaryColor='||CASE WHEN multiple = 1 THEN 1 ELSE 0 END  atts
FROM ApidbTuning.NextGenSeqStats s, 
    (SELECT ceil((csc.mapping_start + 1) / (($rend - $base_start + 1) / 800)) start_interval,
            ceil(csc.mapping_end / (($rend - $base_start + 1) / 800)) end_interval,
            csc.coverage, csc.sample,csc.multiple,ed.name, 
            regexp_substr(csc.sample, '\d{1,}') as hpi
      FROM  apidb.NextGenSeqCoverage csc,
            sres.externaldatabaserelease edr,
            sres.externaldatabase ed
      WHERE csc.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name = $$edname$$
        AND csc.na_sequence_id = $srcfeature_id
        AND csc.mapping_start + 1 <= $rend
        AND csc.mapping_end >= $base_start - 1) c
WHERE c.sample = s.sample
GROUP BY c.start_interval,c.end_interval,c.sample,c.name,c.hpi,c.multiple,s.sum_span_length
      ]]>
      </sql>
   </sqlQuery> 


   <sqlQuery name="NextGenSeq:coverageLogSubtracks:bulksubfeatures"  includeProjects="PlasmoDB,ToxoDB,TriTrypDB,CryptoDB,FungiDB">
     <sql>
<![CDATA[
SELECT start_interval feature_id,
       'NextGenSeq' type,
       '$source' source,
       decode($$negativeValuesField$$, 1, -1, 1) * abs(round(log(2,max(coverage*max_cov/sum_coverage)),2)) score, 
       $$edname$$ || '_' || sample || '_' || $$subtrackField$$ parent_id,
       round(start_interval * (($rend - $base_start + 1) / 800)) startm,
       round(end_interval * (($rend - $base_start + 1) / 800)) end,
       'multiple=' || multiple  || '$dlm' ||
       'sample=' || sample  || '$dlm' || 
       'is_reversed=' || is_reversed  as atts
FROM (SELECT ceil((csc.mapping_start + 1) / (($rend - $base_start + 1) / 800)) start_interval, 
             ceil(csc.mapping_end / (($rend - $base_start + 1) / 800)) end_interval, 
             is_reversed,
             csc.coverage, csc.sample,ed.name, csc.multiple, s.sum_coverage, s.max_cov
      FROM   apidb.NextGenSeqCoverage csc,
             ( SELECT ss.ext_db_name, ss.sample, ss.sum_coverage, m.max_cov
               FROM   apidbtuning.nextgenseqstats ss, 
                      ( SELECT max(sum_coverage) as max_cov, ext_db_name
                        FROM APIDBTUNING.nextgenseqstats
                        GROUP BY ext_db_name) m
               WHERE ss.ext_db_name = m.ext_db_name) s,
             sres.externaldatabaserelease edr,
             sres.externaldatabase ed
      WHERE csc.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name $$operator$$ $$edname$$
        AND csc.na_sequence_id = $srcfeature_id
        AND csc.mapping_start + 1 <= $rend
        AND s.ext_db_name = ed.name
        AND csc.mapping_end >= $base_start - 1)
GROUP BY start_interval,end_interval,sample,is_reversed,multiple, name
]]>
    </sql>
  </sqlQuery>


   <sqlQuery name="NextGenSeq:coverageLog:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
     SELECT start_interval feature_id,
             'NextGenSeq' type,
             '$source' source,
              decode(multiple, 1, -1, 1)*abs(round(log(2,max(coverage)),2)) score, 
             $$sample$$ parent_id,
             round(start_interval * (($rend - $base_start + 1) / 800)) startm,
             round(end_interval * (($rend - $base_start + 1) / 800)) end,
             'binaryColor='||CASE WHEN multiple = 1 THEN 1 ELSE 0 END atts
    FROM (select ceil((csc.mapping_start + 1) / (($rend - $base_start + 1) / 800)) start_interval, 
                 ceil(csc.mapping_end / (($rend - $base_start + 1) / 800)) end_interval, 
                 csc.coverage, csc.sample,csc.multiple
       FROM  apidb.NextGenSeqCoverage csc,
             sres.externaldatabaserelease edr,
             sres.externaldatabase ed
       WHERE csc.external_database_release_id = edr.external_database_release_id
         AND edr.external_database_id = ed.external_database_id
         AND ed.name = $$edname$$ 
         AND csc.na_sequence_id = $srcfeature_id
         AND csc.sample = $$sample$$
         AND csc.mapping_start + 1 <= $rend
         AND csc.mapping_end >= $base_start - 1)
       GROUP BY start_interval,end_interval,sample,multiple
]]>
    </sql>
  </sqlQuery>




<!-- RNA seq bulksubfeature queries. Need one / track as too much data to use filters -->

    <sqlQuery name="rnaseq:gcsample_blat:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
      SELECT rc.location feature_id, 
             'rnaseq' type, 
             'gcsample_blat' source, 
             '' name, 
             rc.coverage score, 
             'gcsample_id' parent_id, 
             rc.location startm, 
             rc.location end, 
             '+1' strand,
             'binaryColor='||rc.multiple atts
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = 'GC_sample'
         AND rc.type = 'max14'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:gcpfwt:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'gcpfwt' source, 
             CASE WHEN multiple = 1 THEN min(coverage) ELSE max(coverage) END score, 
             'gcpfwt_id' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'binaryColor='||multiple atts
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage,rc.multiple
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = 'PF_WT'
         AND rc.type = 'bt'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval,multiple
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:gcbfall:bulksubfeatures"  includeProjects="TriTrypDB">
     <sql>
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'gcbfall' source, 
             CASE WHEN multiple = 1 THEN min(coverage) ELSE max(coverage) END score, 
             'gcbfall_id' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'binaryColor='||multiple atts
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage,rc.multiple
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = 'BF_All'
         AND rc.type = 'bt'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval,multiple
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:cn_three_samples:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT sample||interval feature_id, 
             'rnaseq' type, 
             'cn_three_samples' source, 
             power(2,max(coverage)) score, 
             'cn_three_sample' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'sample='||sample atts
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage, rc.sample
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample in ('24h','8h','40h')
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval,sample
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:cn_four_samples:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT sample||interval feature_id, 
             'rnaseq' type, 
             'cn_four_samples' source, 
             power(2,max(coverage)) score, 
             'cn_four_sample' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end,
             'sample='||sample atts
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage, rc.sample
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample in ('0h','16h','32h','48h')
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval,sample
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:cn_pf0h_lin:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf0h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_0h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '0h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:cn_pf8h_lin:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf8h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_8h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '8h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:cn_pf16h_lin:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf16h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_16h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '16h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:cn_pf24h_lin:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf24h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_24h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '24h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:cn_pf32h_lin:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf32h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_32h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '32h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:cn_pf40h_lin:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf40h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_40h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '40h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
    </sql>
  </sqlQuery>

    <sqlQuery name="rnaseq:cn_pf48h_lin:bulksubfeatures"  includeProjects="PlasmoDB">
     <sql>
<![CDATA[
      SELECT interval feature_id, 
             'rnaseq' type, 
             'cn_pf48h_lin' source, 
             power(2,max(coverage)) score, 
             'rnaseq_48h_lin' parent_id, 
             interval * (($rend - $base_start + 1) / 800) startm, 
             (interval + 1) * (($rend - $base_start + 1) / 800) end
       FROM (select ceil(rc.location / (($rend - $base_start + 1) / 800)) interval, rc.coverage
       FROM  apidb.rnaseq_coverage rc
       WHERE rc.na_sequence_id = $srcfeature_id
         AND rc.sample = '48h'
         AND rc.type = 'p'
         AND rc.location <= $rend
         AND rc.location >= $base_start - 1)
       GROUP BY interval
]]>
    </sql>
  </sqlQuery>

  
  <sqlQuery name="Haplotype:Block:bulksubfeatures">
     <sql>
<![CDATA[
SELECT  cef.source_id feature_id, 
       'Haplotype_Inner' type, 
       'Block' source, 
       cef.name name,
       cef.na_feature_id parent_id, 
       '.' score, 
       nl.start_max startm,            
       nl.end_min end, 
       'Boundary=' || 'Conservative'  || '$dlm' ||'Name=' || cef.name  || '$dlm' || 'SequenceId=' || ens.source_id  as atts
FROM    DoTS.ChromosomeElementFeature cef, Dots.NaLocation nl, DoTS.ExternalNASequence ens
         WHERE  cef.na_sequence_id = $srcfeature_id 
         AND    cef.na_feature_id = nl.na_feature_id 
         AND    ens.na_sequence_id = cef.na_sequence_id
         AND    nl.start_max <= $rend
         AND    nl.end_min >= $base_start
]]>
    </sql>
  </sqlQuery>


</module>
</DAS>

