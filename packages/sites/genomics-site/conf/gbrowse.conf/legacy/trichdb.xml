<DAS>

<!--                        GUS.pm                        --> 
<!-- This is the only query implemented by GUS.pm.        -->
<!-- It's call by get_feature_by_name subroutine.         -->

<module name="GUS.pm"> 
  <sqlQuery> 
    <name>get_feature_by_name</name>
	<description>fetch features by their name</description> 
    <sql>
<![CDATA[
SELECT etn.source_id ctg_name, 
       gf.na_feature_id feature_id, 
       'gene' type, 
       'Genbank' source, 
       gf.source_id name, 
       decode (trp.codon_start, 1, 1, 2, 2, 3, 3, null) phase, 
       etn.na_sequence_id parent_id, 
	   nal.start_max  startm, 
	   nal.end_min end, 
	   decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand, 				
	  ' ' atts
FROM   
       dots.GENEFEATURE gf,
       dots.TRANSCRIPT trp, 
       dots.EXTERNALNASEQUENCE etn, 
       dots.NALOCATION nal 
WHERE  
       gf.na_feature_id = nal.na_feature_id and
       trp.parent_id = gf.na_feature_id and
       gf.na_sequence_id = etn.na_sequence_id and
       ( upper(gf.source_id) like upper('$name') or 
       upper(trp.protein_id) like upper('$name') or
       upper(etn.source_id) like upper('$name') or 
	   upper(trp.product) like upper('%$name%') )
]]>
    </sql>
  </sqlQuery>   
</module>

<!--                       Segment.pm                                 --> 
<!-- Feature names are in the same format as the config - type:Source -->

<module name="Segment.pm">
  <sqlQuery>
    <name>new:Segment</name>
    <description>Normally, a segment is a chromosome, contig...  
                 Use na_sequence_id as srcfeature_id
    </description>
    <sql>
<![CDATA[
SELECT etn.na_sequence_id srcfeature_id, 
       1 startm, 
       etn.length end, 
       etn.source_id name, 
       'contig' type, 
       ' ' atts
FROM   dots.EXTERNALNASEQUENCE etn 
WHERE  upper(etn.source_id) = upper('$name') 
]]>
    </sql>
  </sqlQuery>   

  <sqlQuery> 
    <name>get_sequence</name> 
    <description></description> 
    <sql> 
<![CDATA[ 
SELECT ens.sequence 
FROM   DOTS.EXTERNALNASEQUENCE ens 
WHERE  ens.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>   

  <sqlQuery>
    <name>gene:Genbank</name>
	<description>Use outer join because those 409 C.parvum un-annoated 
                 genes are not visible otherwise 
    </description>
    <sql>
<![CDATA[ 
SELECT gf.na_feature_id feature_id,
       'gene' type, 
       'Genbank' source, 
       gf.source_id name, 
       '.' score, 
       trp.codon_start phase,
       gf.na_sequence_id parent_id, 
       nal.start_max startm, 
       nal.end_min end, 
       decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Name=' || trp.source_id || '$dlm' ||
       'Type=' || gf.name || '$dlm' ||
       'Note=' || trp.product atts
FROM   dots.GENEFEATURE gf, 
       dots.TRANSCRIPT trp,
       dots.NALOCATION nal,
       sres.SEQUENCEONTOLOGY so
WHERE  so.sequence_ontology_id = gf.sequence_ontology_id and
       so.term_name != 'repeat_region' and
       gf.na_feature_id = nal.na_feature_id and 
       trp.parent_id = gf.na_feature_id and
       nal.start_max <= $rend and 
       nal.end_min >= $base_start and 
       gf.na_sequence_id = $srcfeature_id 
ORDER BY 
       nal.start_max
]]>
    </sql>
  </sqlQuery>   

  <sqlQuery>
    <name>repeat_region:Genbank</name>
	  <description></description>
    <sql>
<![CDATA[ 
SELECT gf.na_feature_id feature_id,
       'repeat_region' type, 
       'Genbank' source, 
       gf.source_id name, 
       gf.na_sequence_id parent_id, 
       ga.start_min startm, 
       ga.end_max end, 
       decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand,
       'Name=' || gf.source_id || '$dlm' ||
       'Type=' || ga.so_term_name || '$dlm' ||
       'Note=' || ga.product atts
FROM   dots.GENEFEATURE gf, 
       dots.NALOCATION nal,
       apidb.GeneAttributes ga 
WHERE  ga.so_term_name = 'repeat_region'
   AND nal.na_feature_id = gf.na_feature_id
   AND ga.start_min <= $rend 
   AND ga.end_max >= $base_start 
   AND gf.source_id = ga.source_id
   AND gf.na_sequence_id = $srcfeature_id 
]]>
    </sql>
  </sqlQuery>   

  <sqlQuery> 
    <name>annotation:density</name> 
    <description>Annotation density. bin size is 50K.</description> 
    <sql> 
<![CDATA[ 
SELECT etn.na_sequence_id feature_id, 
       'annotation' type, 
       'density' source 
FROM   dots.EXTERNALNASEQUENCE etn 
WHERE  etn.na_sequence_id = $srcfeature_id 
]]> 
    </sql> 
  </sqlQuery>

  <sqlQuery>
    <name>alignment:ORF</name>
    <description></description>
    <sql>
    <![CDATA[ 
SELECT taaf.na_feature_id feature_id, 
       'alignment' type, 
       so.term_name source, 
       t    .source_id name, 
       '' score, 
       enas.na_sequence_id parent_id, 
       nal.start_min startm, 
       nal.end_max end, 
       decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand
FROM
       dots.externalnasequence enas,
       dots.miscellaneous t,
       dots.translatedaafeature taaf, 
       dots.translatedaasequence taas, 
       sres.taxonname tn, 
       sres.sequenceontology so, 
       dots.nalocation nal 
WHERE
       t.na_feature_id = taaf.na_feature_id
       AND taaf.aa_sequence_id = taas.aa_sequence_id
       AND enas.na_sequence_id = t.na_sequence_id 
       AND enas.taxon_id = tn.taxon_id
       AND tn.name_class = 'scientific name'
       AND t.sequence_ontology_id = so.sequence_ontology_id
       AND so.term_name = 'ORF'
       AND taaf.na_feature_id = nal.na_feature_id
       AND enas.na_sequence_id = $srcfeature_id
       AND nal.start_min >= $base_start - 1 
       AND nal.end_max <= $rend
ORDER BY nal.start_min
]]>
    </sql>
  </sqlQuery>

  <sqlQuery>
    <name>alignment:BLAT</name>
    <description></description>
    <sql>
<![CDATA[ 
SELECT blat.blat_alignment_id feature_id, 
       'alignment' type, 
       'BLAT' source, 
       est.accession name, 
       blat.score || '' score, 
       etn.na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'Direction=' || est.p_end || ' prime' || '$dlm' ||
			 'PCT=' || blat.percent_identity atts
FROM   
       dots.BLATALIGNMENT blat, 
       dots.ASSEMBLYSEQUENCE asbl, 
       dots.EST est, 
       dots.EXTERNALNASEQUENCE etn
WHERE  
       blat.query_na_sequence_id = asbl.na_sequence_id and 
       blat.target_na_sequence_id = etn.na_sequence_id and 
       est.na_sequence_id = asbl.na_sequence_id and 
       blat.target_start >= $base_start -1 and 
       blat.target_end <= $rend and 
	     etn.external_database_release_id = blat.target_external_db_release_id and
       (blat.target_end - blat.target_start ) < 5000 and 
			 blat.is_best_alignment = 1 and
       etn.na_sequence_id = $srcfeature_id 
ORDER BY blat.target_start asc, blat.score desc
]]>
    </sql>
  </sqlQuery>   

  <sqlQuery>
    <name>alignment:EST</name>
    <description></description>
    <sql>
<![CDATA[ 
SELECT blat.blat_alignment_id feature_id, 
       'alignment' type, 
       'EST' source, 
       est.accession name, 
       blat.score || '' score, 
       etn.na_sequence_id parent_id, 
       blat.target_start startm, 
       blat.target_end end, 
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'Direction=' || est.p_end || ' prime' || '$dlm' ||
			 'PCT=' || blat.percent_identity atts
FROM   
       dots.BLATALIGNMENT blat, 
       dots.ASSEMBLYSEQUENCE asbl, 
       dots.EST est, 
       dots.EXTERNALNASEQUENCE etn
WHERE  
       blat.query_na_sequence_id = asbl.na_sequence_id and 
       blat.target_na_sequence_id = etn.na_sequence_id and 
       est.na_sequence_id = asbl.na_sequence_id and 
       blat.target_start >= $base_start -1 and 
       blat.target_end <= $rend and 
	     etn.external_database_release_id = blat.target_external_db_release_id and
       (blat.target_end - blat.target_start ) < 5000 and 
			 blat.is_best_alignment = 1 and
       etn.na_sequence_id = $srcfeature_id 
ORDER BY blat.target_start asc, blat.score desc
]]>
    </sql>
  </sqlQuery>   

  <sqlQuery>
    <name>match:WU_BLASTX</name>
    <description></description>
    <sql>
<![CDATA[ 
SELECT sim.similarity_id feature_id, 
       'match' type, 
       'WU_BLASTX' source, 
       extt.source_id name, 
       sim.score || '' score, 
       extq.na_sequence_id parent_id, 
       sim.min_query_start startm, 
       sim.max_query_end end, 
       decode (sim.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       'Score=' || sim.score || '$dlm' || 
       'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||'$dlm'|| 
       'description=' || extt.description || '$dlm' || 
       'TStart=' || sim.min_subject_start || '$dlm' || 
       'TStop=' || sim.max_subject_end atts 
FROM   
       dots.SIMILARITY sim, 
       dots.EXTERNALAASEQUENCE extt, 
       dots.EXTERNALNASEQUENCE extq
WHERE  
       sim.query_id = extq.na_sequence_id and 
       sim.subject_id = extt.aa_sequence_id and 
       (sim.max_query_end - sim.min_query_start) < 5000 and 
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) < 1e-10 and 
       sim.min_query_start >= $base_start and 
       sim.max_query_end <= $rend and 
       extq.na_sequence_id = $srcfeature_id and 
       RowNum < 4000 
ORDER BY 
       sim.min_query_start asc, 
       sim.max_query_end asc, 
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) asc, 
       sim.total_match_length desc
]]>
    </sql>
  </sqlQuery>   

</module>

<!--                       Feature.pm                         -->
<!-- Description: All of the following queries are used by    -->
<!-- sub_SeqFeatures() in Feature.pm.                         --> 
<!-- Names are in a format - type:source:subfeatures,         --> 
<!-- e.g.  gene:Genbank:subfeatures                           --> 
<!-- They should be corespondent with the features types      --> 
<!-- implemented in feature() subroutine in Segment.pm        -->

<module name="Feature.pm">

	<sqlQuery>
	  <name>gene:Genbank:bulksubfeatures</name>
		<description></description>
		<sql>
<![CDATA[
SELECT exf.na_feature_id feature_id,
			 exf.name type,
			 'Genbank' source,
			 exf.na_feature_id name,
			 gf.na_feature_id parent_id,
			 nal.start_min startm,
			 nal.end_max end,
			 decode (nal.is_reversed, 0, '+1', 1, '-1', '.') strand
FROM   dots.EXONFEATURE exf,
			 dots.GeneFeature gf,
			 dots.NALOCATION nal
WHERE  exf.na_sequence_id = $srcfeature_id
			 AND  gf.na_feature_id = exf.parent_id
			 AND  nal.na_feature_id = exf.na_feature_id
			 AND  nal.start_max <= $rend
			 AND  nal.end_min >= $base_start
ORDER BY nal.start_max
]]>
		</sql>
	</sqlQuery>

  <sqlQuery> 
    <name>annotation:density:subfeatures</name> 
    <description>Annotation density subfeatures. Bin size is 50K. 
    </description> 
    <sql> 
<![CDATA[ 
SELECT interval feature_id, 
      'test' type, 
      'test' source, 
      count(interval) score, 
      (interval - 1) * 30000 startm, 
      interval * 30000 end 
FROM ( 
      SELECT ceil(nal.start_max / 30000) interval 
      FROM   dots.GENEFEATURE gf, dots.NALOCATION nal 
      WHERE  gf.na_feature_id = nal.na_feature_id and 
             gf.na_sequence_id = $parent_id 
      ORDER BY nal.start_max) 
GROUP BY interval 
]]> 
    </sql> 
  </sqlQuery>

  <sqlQuery>
    <name>match:WU_BLASTX:subfeatures</name>
    <description></description>
    <sql>
<![CDATA[ 
SELECT simp.similarity_span_id feature_id, 
       'HSP' type, 
       'WU_BLASTX' source, 
       simp.similarity_span_id name, 
       '.' phase, 
       simp.score || '' score, 
       simp.query_start startm, 
       simp.query_end end, 
       decode (simp.is_reversed, 0, '+1', 1, '-1', '.') strand, 
       '' atts 
FROM   dots.similarity sim, dots.similarityspan simp 
WHERE  sim.similarity_id = simp.similarity_id and 
       sim.similarity_id  = $parent_id
]]>
    </sql>
  </sqlQuery>   

  <sqlQuery>
    <name>alignment:BLAT:subfeatures</name>
    <description></description>
    <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type,
       'BLAT' source,
       est.accession name,
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES
FROM   dots.BLATALIGNMENT blat,
       dots.ASSEMBLYSEQUENCE asbl,
       dots.EST est,
       dots.EXTERNALNASEQUENCE etn
WHERE  blat.query_na_sequence_id = asbl.na_sequence_id and
       blat.target_na_sequence_id = etn.na_sequence_id and
       est.na_sequence_id = asbl.na_sequence_id and
       blat.blat_alignment_id = $parent_id
]]>
    </sql>
  </sqlQuery>

  <sqlQuery>
    <name>alignment:EST:subfeatures</name>
    <description></description>
    <sql>
<![CDATA[
SELECT blat.blat_alignment_id feature_id,
       'block' type,
       'EST' source,
       est.accession name,
       blat.score || '' score,
       blat.blat_alignment_id parent_id,
       blat.target_start startm,
       blat.target_end end,
       decode (blat.is_reversed, 0, '+1', 1, '-1', '.') strand,
       blat.tstarts TSTARTS,
       blat.blocksizes BLOCKSIZES
FROM   dots.BLATALIGNMENT blat,
       dots.ASSEMBLYSEQUENCE asbl,
       dots.EST est,
       dots.EXTERNALNASEQUENCE etn
WHERE  blat.query_na_sequence_id = asbl.na_sequence_id and
       blat.target_na_sequence_id = etn.na_sequence_id and
       est.na_sequence_id = asbl.na_sequence_id and
       blat.blat_alignment_id = $parent_id
]]>
    </sql>
  </sqlQuery>

  <sqlQuery>
    <name>protein:seq</name>
    <description>Retrive protein sequence from GUS</description>
    <sql>
<![CDATA[ 
SELECT trp.protein_id, trp.source_id, tas.sequence 
FROM   DOTS.TRANSLATEDAASEQUENCE tas, 
       DOTS.TRANSLATEDAAFEATURE taf, 
       DOTS.TRANSCRIPT trp 
WHERE  
       tas.aa_sequence_id = taf.aa_sequence_id and 
       trp.na_feature_id = taf.na_feature_id and 
       trp.na_feature_id = '$id'
]]>
    </sql>
  </sqlQuery>   

  <sqlQuery>
    <name>template</name>
    <description></description>
    <sql>
<![CDATA[ 
]]>
    </sql>
  </sqlQuery>   
</module>
</DAS>
