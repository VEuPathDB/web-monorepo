--- Session.pm.orig	2012-05-04 13:19:13.000000000 -0400
+++ Session.pm	2012-05-04 16:43:33.000000000 -0400
@@ -15,14 +15,18 @@
 use constant LOCK_TIMEOUT => 10;
 eval "require Time::HiRes;";
 
+use GBrowse::Configuration;
+
 my $HAS_NFSLOCK;
 my $HAS_MYSQL;
+my $HAS_ORACLE;
 
 BEGIN {
     # Prevent CGI::Session from autoflushing. Only flush when we say to.
     undef *CGI::Session::DESTROY;
     $HAS_NFSLOCK = eval {require File::NFSLock;1           };
     $HAS_MYSQL   = eval {require DBI; require DBD::mysql; 1};
+    $HAS_ORACLE  = eval {require DBI; require DBD::Oracle; 1};
 }
 
 use constant DEBUG => 0;
@@ -31,6 +35,7 @@
 sub new {
 	my $class    = shift;
 	my %args     = @_;
+	
 	my ($driver,$id,$session_args,$default_source,$lockdir,$locktype,$expire_time,$mode) 
 	  = @args{'driver','id','args','source','lockdir','locktype','expires','mode'};
 
@@ -100,19 +105,28 @@
 
 sub locktype {
     my $self = shift;
+
     if ($self->{locktype} eq 'default') {
 	return 'flock';
     }
     return 'nfs'   if $self->{locktype} eq 'nfs'                     && $HAS_NFSLOCK;
-    return 'mysql' if $self->{locktype} =~ /^(dbi:mysql|mysql):/    && $HAS_MYSQL;
+    return 'mysql' if $self->{locktype} =~ /^(dbi:mysql|mysql):/     && $HAS_MYSQL;
+    return 'oracle' if $self->{locktype} =~ /^(dbi:oracle|oracle):/  && $HAS_ORACLE;
     return 'flock' if $self->{locktype} eq 'flock';
 }
 
+sub getProcessInfo {
+		 my $nodename = `uname -n`;
+		 chomp($nodename);
+	return 		  "process $$" || $nodename;
+
+}
+
 sub lock {
     my $self    = shift;
     my $type    = shift;
     my $id      = shift;
-    
+
     # no id, so we have to create a session and get an id
     # otherwise we lock before we make the session
     unless ($id) {
@@ -121,7 +135,8 @@
     }
 
     return if $self->lockobj; # don't double lock
-    my $locktype = $self->locktype;
+    my $locktype = $self->{locktype};
+    #my $locktype = $self->locktype;
     my $start_time = $self->time();
 
     warn '[',$self->time,'] ',"[$$] waiting on $type session lock...\n" if DEBUG_LOCK;
@@ -142,6 +157,9 @@
 	elsif ($locktype eq 'mysql') {
 	    $self->lock_mysql($type,$id);
 	}
+	elsif ($locktype eq 'oracle') {
+	    $self->lock_oracle($type,$id);
+	}
 	else {
 	    die "unknown lock type $locktype";
 	}
@@ -211,6 +229,36 @@
     $self->lockobj($dbh);
 }
 
+sub lock_oracle {
+    my $self = shift;
+    my ($type,$id) = @_;
+    $SIG{PIPE} = 'IGNORE';
+    return if $type eq 'shared';
+    my $lock_name  = $self->oracle_lock_name($id);
+
+    my $cfg = new GBrowse::Configuration;
+    my $dsn = $cfg->userDB->{-dsn};
+    my $user = $cfg->userDB->{-user};
+    my $pass = $cfg->userDB->{-pass};
+    my $dbh  = DBI->connect($dsn, $user, $pass) or die "Session has no dbh handle!";
+    my $processInfo = &getProcessInfo();
+
+my $sql = <<SQL;
+update apidb.GBrowseLock
+set current_updater = '$processInfo', update_start = sysdate
+where current_updater is null
+SQL
+
+    $dbh->do($sql);
+
+    my $stmt = $dbh->prepare("select current_updater from apidb.GBrowseLock");
+    $stmt->execute();
+    my $result = $stmt->fetchrow_arrayref();
+
+    warn "Could not get my lock on $id" unless $result->[0];
+    $self->lockobj($dbh);
+}
+
 sub lock_sh {
     shift->lock('shared',@_);
 }
@@ -223,8 +271,15 @@
     my $lock = $self->lockobj or return;
     warn '[',$self->time,'] ',"[$$] session unlock" if DEBUG_LOCK;
     if ($lock->isa('DBI::db')) {
-	my $lock_name = $self->mysql_lock_name($self->id);
-	my $result = $lock->do("SELECT RELEASE_LOCK('$lock_name')");
+       if($self->{locktype} =~ /mysql/i) {
+          my $lock_name = $self->mysql_lock_name($self->id);
+          my $result = $lock->do("SELECT RELEASE_LOCK('$lock_name')");
+       } elsif( $self->{locktype} =~ /oracle/i) {
+          my $lock_name = $self->oracle_lock_name($self->id);
+          my $processInfo = &getProcessInfo();
+          my $result = $lock->do("update apidb.GBrowseLock set current_updater = null, update_start = null where current_updater = '$processInfo'");
+
+      }
     }
     $self->lockobj(undef);
     my $action = CGI::param('action');
@@ -245,6 +300,12 @@
     return "gbrowse_session_lock.$id";
 }
 
+sub oracle_lock_name {
+    my $self = shift;
+    my $id   = shift;
+    return "gbrowse_session_lock.$id";
+}
+
 # handle the lock when forking occurs
 sub was_forked {
     my $self  = shift;
